<quasar-background></quasar-background>

<style is:global>
  quasar-background {
    position: fixed !important;
    inset: 0 !important;
    width: 100vw !important;
    height: 100dvh !important;
    z-index: -1 !important;
    pointer-events: none !important;
  }
</style>

<script>
  const COUNT = 210;
  const SPEED = 0.05;
  const MAX_DT = 2;

  const reduceMotionMq = window.matchMedia("(prefers-reduced-motion: reduce)");
  const reduced = () => reduceMotionMq.matches;

  function readVars() {
    const s = getComputedStyle(document.documentElement);
    return {
      pulse: parseFloat(s.getPropertyValue("--pulse")) || 0.5,
      decay: parseFloat(s.getPropertyValue("--pulse-decay")) || 1,
      proximity: parseFloat(s.getPropertyValue("--search-proximity")) || 0,
    };
  }

  class Star {
    constructor(cx, cy, spread) {
      this.cx = cx;
      this.cy = cy;
      this.spread = spread;
      this.reset();
    }

    reset() {
      this.x = this.cx + (Math.random() - 0.5) * this.spread;
      this.y = this.cy + (Math.random() - 0.5) * this.spread;
      this.z = Math.random();
      this.xPrev = this.x;
      this.yPrev = this.y;
    }

    update(speed, dt, compression) {
      this.xPrev = this.x;
      this.yPrev = this.y;
      this.z += speed * 0.07 * dt;

      // radial compression toward center
      const dx = this.x - this.cx;
      const dy = this.y - this.cy;
      this.x += dx * speed * this.z * dt * compression;
      this.y += dy * speed * this.z * dt * compression;

      const half = this.spread / 2;
      if (
        this.x < this.cx - half ||
        this.x > this.cx + half ||
        this.y < this.cy - half ||
        this.y > this.cy + half
      ) {
        this.reset();
      }
    }

    draw(ctx, light, alpha) {
      ctx.strokeStyle = light
        ? `rgba(0,0,0,${alpha})`
        : `rgba(255,255,255,${alpha})`;
      ctx.lineWidth = Math.min(this.z * 0.6, 2);
      ctx.beginPath();
      ctx.moveTo(this.xPrev, this.yPrev);
      ctx.lineTo(this.x, this.y);
      ctx.stroke();
    }
  }

  class QuasarBackground extends HTMLElement {
    constructor() {
      super();
      this.canvas = document.createElement("canvas");
      this.ctx = this.canvas.getContext("2d");
      this.stars = [];
      this.lastTime = 0;
      this.isLight = false;
    }

    connectedCallback() {
      this.appendChild(this.canvas);
      this.resize();
      this.watchTheme();
      requestAnimationFrame(this.frame);
    }

    resize = () => {
      const w = window.innerWidth;
      const h = window.innerHeight;
      const dpr = Math.min(window.devicePixelRatio || 1, 2);

      this.canvas.width = w * dpr;
      this.canvas.height = h * dpr;
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      const cx = w / 2;
      const cy = h / 2;
      const spread = Math.max(w, h) * 1.3;

      this.stars = Array.from(
        { length: COUNT },
        () => new Star(cx, cy, spread),
      );
    };

    watchTheme() {
      const update = () => {
        this.isLight = document.documentElement.classList.contains("light");
      };
      update();
      new MutationObserver(update).observe(document.documentElement, {
        attributes: true,
        attributeFilter: ["class"],
      });
    }

    frame = (t) => {
      if (document.hidden || reduced()) return;

      const dt = Math.min((t - this.lastTime) / 16.67, MAX_DT);
      this.lastTime = t;

      const { pulse, decay, proximity } = readVars();

      // compression factor (1 â†’ 0.94 max)
      const compression = 1 - 0.06 * proximity;
      const alphaGain = 0.75 + 0.25 * pulse * decay;

      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

      for (const s of this.stars) {
        s.update(SPEED, dt, compression);
        s.draw(this.ctx, this.isLight, Math.min(s.z, 1) * alphaGain);
      }

      requestAnimationFrame(this.frame);
    };
  }

  if (!customElements.get("quasar-background")) {
    customElements.define("quasar-background", QuasarBackground);
  }
</script>
