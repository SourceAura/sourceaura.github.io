<quasar-background></quasar-background>

<style is:global>
  quasar-background {
    position: fixed !important;
    inset: 0 !important;
    width: 100vw !important;
    height: 100dvh !important;
    display: block !important;
    z-index: -1 !important;
    pointer-events: none !important;
    margin: 0;
    padding: 0;
    overflow: hidden;
  }

  quasar-background canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100% !important;
    height: 100% !important;
    display: block;
  }
</style>

<script>
  const COUNT = 210;
  const SPEED = 0.05;
  const MAX_DT = 2;

  const lerp = (a, b, t) => a + (b - a) * t;
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

  class Star {
    constructor(spread) {
      this.spread = spread;
      this.reset(0, 0, spread);
    }

    reset(cx, cy, spread) {
      this.x = cx + (Math.random() - 0.5) * spread;
      this.y = cy + (Math.random() - 0.5) * spread;
      this.z = Math.random();
      this.xPrev = this.x;
      this.yPrev = this.y;
    }

    update(cx, cy, spread, speed, dt) {
      this.xPrev = this.x;
      this.yPrev = this.y;

      this.z += speed * 0.07 * dt;
      this.x += (this.x - cx) * speed * this.z * dt;
      this.y += (this.y - cy) * speed * this.z * dt;

      const half = spread / 2;
      if (
        this.x < cx - half ||
        this.x > cx + half ||
        this.y < cy - half ||
        this.y > cy + half
      ) {
        this.reset(cx, cy, spread);
      }
    }

    draw(ctx, light) {
      const a = Math.min(this.z, 1);
      ctx.strokeStyle = light ? `rgba(0,0,0,${a})` : `rgba(255,255,255,${a})`;
      ctx.lineWidth = Math.min(this.z * 0.6, 2);
      ctx.beginPath();
      ctx.moveTo(this.xPrev, this.yPrev);
      ctx.lineTo(this.x, this.y);
      ctx.stroke();
    }
  }

  class QuasarBackground extends HTMLElement {
    constructor() {
      super();
      this.canvas = document.createElement("canvas");
      this.ctx = this.canvas.getContext("2d", { alpha: true });

      this.stars = [];
      this.lastTime = 0;
      this.lastDraw = 0;
      this.isLight = false;

      this.base = { cx: 0, cy: 0, spread: 0 };
      this.influence = { x: 0.5, y: 0.5, a: 0, d: 0 };
      this.influenceLive = { x: 0.5, y: 0.5, a: 0, d: 0 };

      this._mounted = false;
      this._raf = 0;

      this._w = 0;
      this._h = 0;

      this._isMobile =
        matchMedia("(max-width: 768px)").matches ||
        /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

      // Cap DPR a bit harder on mobile to reduce fill-rate
      this._dprCap = this._isMobile ? 1.6 : 2;

      // FPS cap: mobile gets calmer updates, desktop stays smooth
      this._fps = this._isMobile ? 30 : 60;
      this._minFrameMs = 1000 / this._fps;

      this._resizeQueued = false;
      this._themeMO = null;

      this._onPetalLight = (e) => {
        const d = e.detail || {};
        this.influence.x = clamp(d.x ?? 0.5, 0, 1);
        this.influence.y = clamp(d.y ?? 0.5, 0, 1);
        this.influence.a = clamp(d.a ?? 0, 0, 1);
        this.influence.d = clamp(d.d ?? 0, 0, 1);
      };

      this._onVisibility = () => {
        if (document.hidden) {
          if (this._raf) cancelAnimationFrame(this._raf);
          this._raf = 0;
          return;
        }
        // resume
        this.lastTime = performance.now();
        this.lastDraw = 0;
        if (!this._raf) this._raf = requestAnimationFrame(this.frame);
      };

      this._onResize = () => this.queueResize();
    }

    connectedCallback() {
      // Guard against double-mount
      if (this._mounted) return;
      this._mounted = true;

      this.appendChild(this.canvas);

      if (window.visualViewport) {
        window.visualViewport.addEventListener("resize", this._onResize, {
          passive: true,
        });
      } else {
        window.addEventListener("resize", this._onResize, { passive: true });
      }
      window.addEventListener("orientationchange", this._onResize, {
        passive: true,
      });

      window.addEventListener("petal:light", this._onPetalLight, {
        passive: true,
      });

      document.addEventListener("visibilitychange", this._onVisibility, {
        passive: true,
      });

      this.resize(true);
      this.watchTheme();

      this.lastTime = performance.now();
      this._raf = requestAnimationFrame(this.frame);
    }

    disconnectedCallback() {
      // Cleanup (prevents leaks on Astro swaps)
      if (this._raf) cancelAnimationFrame(this._raf);
      this._raf = 0;

      if (window.visualViewport) {
        window.visualViewport.removeEventListener("resize", this._onResize);
      } else {
        window.removeEventListener("resize", this._onResize);
      }
      window.removeEventListener("orientationchange", this._onResize);

      window.removeEventListener("petal:light", this._onPetalLight);
      document.removeEventListener("visibilitychange", this._onVisibility);

      this._themeMO?.disconnect?.();
      this._themeMO = null;

      this._mounted = false;
    }

    queueResize() {
      if (this._resizeQueued) return;
      this._resizeQueued = true;
      requestAnimationFrame(() => {
        this._resizeQueued = false;
        this.resize(false);
      });
    }

    resize(force) {
      const width = window.visualViewport
        ? Math.round(window.visualViewport.width)
        : Math.round(window.innerWidth);
      const height = window.visualViewport
        ? Math.round(window.visualViewport.height)
        : Math.round(window.innerHeight);

      // Prevent thrash: only re-layout if size truly changed
      if (!force && width === this._w && height === this._h) return;

      this._w = width;
      this._h = height;

      const dpr = Math.min(window.devicePixelRatio || 1, this._dprCap);

      this.canvas.width = Math.max(1, Math.floor(width * dpr));
      this.canvas.height = Math.max(1, Math.floor(height * dpr));
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      this.base.cx = width / 2;
      this.base.cy = height / 2;
      this.base.spread = Math.max(width, height) * 1.3;

      // Keep the same “field”, but lighten density on mobile a bit.
      const targetCount = this._isMobile ? Math.round(COUNT * 0.72) : COUNT;

      // Only rebuild stars when needed
      if (this.stars.length !== targetCount) {
        this.stars = Array.from(
          { length: targetCount },
          () => new Star(this.base.spread),
        );
      }

      for (const s of this.stars)
        s.reset(this.base.cx, this.base.cy, this.base.spread);
    }

    watchTheme() {
      const update = () => {
        this.isLight = document.documentElement.classList.contains("light");
      };
      update();
      this._themeMO = new MutationObserver(update);
      this._themeMO.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ["class"],
      });
    }

    frame = (t) => {
      if (document.hidden) return; // extra safety

      // FPS cap (mobile)
      if (this.lastDraw && t - this.lastDraw < this._minFrameMs) {
        this._raf = requestAnimationFrame(this.frame);
        return;
      }
      this.lastDraw = t;

      const dt = Math.min((t - this.lastTime) / 16.67, MAX_DT);
      this.lastTime = t;

      // Smooth influence so it feels like gravity, not a pointer
      this.influenceLive.x = lerp(this.influenceLive.x, this.influence.x, 0.08);
      this.influenceLive.y = lerp(this.influenceLive.y, this.influence.y, 0.08);
      this.influenceLive.a = lerp(this.influenceLive.a, this.influence.a, 0.06);
      this.influenceLive.d = lerp(this.influenceLive.d, this.influence.d, 0.06);

      const width =
        this._w ||
        (window.visualViewport
          ? window.visualViewport.width
          : window.innerWidth);
      const height =
        this._h ||
        (window.visualViewport
          ? window.visualViewport.height
          : window.innerHeight);

      const shiftMax = 18;
      const dx = (this.influenceLive.x - 0.5) * 2;
      const dy = (this.influenceLive.y - 0.5) * 2;

      const cx = this.base.cx + dx * shiftMax * this.influenceLive.a;
      const cy = this.base.cy + dy * shiftMax * this.influenceLive.a;

      const compress = 1 - 0.1 * this.influenceLive.a;
      const spread = this.base.spread * compress;

      // Clear (use cached width/height)
      this.ctx.clearRect(0, 0, width, height);

      for (const s of this.stars) {
        s.update(cx, cy, spread, SPEED, dt);
        s.draw(this.ctx, this.isLight);
      }

      this._raf = requestAnimationFrame(this.frame);
    };
  }

  if (!customElements.get("quasar-background")) {
    customElements.define("quasar-background", QuasarBackground);
  }
</script>
