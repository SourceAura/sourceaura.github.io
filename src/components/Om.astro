---
/* Om – The Oscillator
 * Global temporal field.
 * Adds:
 * - Circadian drift (local time bias)
 * - Long-idle sigh
 * - Route-change harmonic spike
 * - Lunar 28-day modulation
 * - Weather-based micro variance (Open-Meteo)
 * - Keyboard cadence entrainment
 */
---

<script is:inline>
  (() => {
    const root = document.documentElement;

    const reduceMotion = window.matchMedia?.(
      "(prefers-reduced-motion: reduce)",
    );
    const isReduced = () => !!reduceMotion?.matches;

    // Guard: avoid double-mount on Astro client navigation
    if (window.__pulse?.__mounted) return;

    const isMobile =
      matchMedia("(max-width: 768px)").matches ||
      /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

    let lastInteraction = performance.now();
    let lastRoute = location.pathname;

    /* ── TEMPO TARGETS ── */
    const BASE_DAY_HZ = 0.68;
    const BASE_NIGHT_HZ = 0.5;
    const BOOST_HZ = 1.18;
    const SIGH_HZ = 0.42;

    let boosted = false;
    let sighing = false;
    let phase = 0;
    let raf = 0;
    let running = false;

    // FPS cap (mobile)
    const FPS = isMobile ? 30 : 60;
    const MIN_MS = 1000 / FPS;
    let lastTick = 0;

    /* ── LUNAR (28-day aesthetic cycle) ── */
    function getLunar28() {
      const msPerDay = 86400000;
      const epoch = Date.UTC(2000, 0, 1);
      const now = Date.now();
      const days = (now - epoch) / msPerDay;
      const p = (days % 28) / 28;
      return 0.5 - 0.5 * Math.cos(p * Math.PI * 2);
    }

    /* ── CIRCADIAN ── */
    function getCircadianHz() {
      const now = new Date();
      const hour = now.getHours() + now.getMinutes() / 60;
      const daylight = Math.cos(((hour - 12) / 24) * Math.PI * 2) * -0.5 + 0.5;
      return BASE_NIGHT_HZ + daylight * (BASE_DAY_HZ - BASE_NIGHT_HZ);
    }

    /* ── WEATHER MICRO VARIANCE ── */
    let weatherEnergy = 0.12;
    let lastWeatherFetch = 0;

    const FALLBACK = { lat: 40.7128, lon: -74.006 };

    function getStoredCoords() {
      try {
        const raw = localStorage.getItem("__om_coords");
        if (!raw) return null;
        const obj = JSON.parse(raw);
        if (typeof obj?.lat === "number" && typeof obj?.lon === "number")
          return obj;
      } catch {}
      return null;
    }

    function storeCoords(lat, lon) {
      try {
        localStorage.setItem("__om_coords", JSON.stringify({ lat, lon }));
      } catch {}
    }

    async function fetchWeather(lat, lon) {
      const url =
        `https://api.open-meteo.com/v1/forecast?latitude=${encodeURIComponent(
          lat,
        )}&longitude=${encodeURIComponent(lon)}` +
        `&current=temperature_2m,precipitation,cloud_cover,wind_speed_10m` +
        `&timezone=auto`;

      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error("weather fetch failed");

      const cur = (await res.json())?.current || {};

      const windN = Math.min(Number(cur.wind_speed_10m ?? 0) / 35, 1);
      const precipN = Math.min(Number(cur.precipitation ?? 0) / 6, 1);
      const cloudN = Math.min(Number(cur.cloud_cover ?? 0) / 100, 1);

      weatherEnergy = Math.max(
        0,
        Math.min(1, 0.08 + windN * 0.18 + precipN * 0.34 + cloudN * 0.1),
      );

      root.style.setProperty("--pulse-weather", weatherEnergy.toFixed(4));
    }

    function scheduleWeatherFetch(t) {
      const THIRTY_MIN = 30 * 60 * 1000;
      if (t - lastWeatherFetch < THIRTY_MIN) return;
      lastWeatherFetch = t;

      const stored = getStoredCoords();
      const run = async (lat, lon) => {
        storeCoords(lat, lon);
        try {
          await fetchWeather(lat, lon);
        } catch {}
      };

      if (stored) return run(stored.lat, stored.lon);

      navigator.geolocation?.getCurrentPosition(
        (pos) => run(pos.coords.latitude, pos.coords.longitude),
        () => run(FALLBACK.lat, FALLBACK.lon),
        { maximumAge: 6 * 60 * 60 * 1000, timeout: 2500 },
      );
    }

    /* ── KEYBOARD CADENCE ENTRAINMENT ── */
    let cadenceEnergy = 0;
    let cadenceHz = 0.9;
    const intervals = [];
    let lastKeyTime = 0;

    function onKeydown() {
      const now = performance.now();
      if (lastKeyTime) {
        const dt = now - lastKeyTime;
        if (dt > 30 && dt < 900) {
          intervals.push(dt);
          if (intervals.length > 10) intervals.shift();
          const avg = intervals.reduce((a, b) => a + b, 0) / intervals.length;
          cadenceHz = Math.max(0.6, Math.min(1.8, (1000 / avg) * 0.65));
          cadenceEnergy = Math.min(1, cadenceEnergy + 0.18);
        }
      }
      lastKeyTime = now;
      touch();
    }

    window.addEventListener("keydown", onKeydown, { passive: true });

    function writeVars(pulse, decay, ph, spike, lunar) {
      root.style.setProperty("--pulse", pulse);
      root.style.setProperty("--pulse-decay", decay);
      root.style.setProperty("--pulse-phase", ph);
      root.style.setProperty("--pulse-spike", spike);
      root.style.setProperty("--pulse-lunar", lunar);
    }

    function touch() {
      lastInteraction = performance.now();
      sighing = false;
    }

    function setBoost(on) {
      boosted = !!on;
      touch();
    }

    function start() {
      if (running) return;
      running = true;
      lastTick = 0;
      raf = requestAnimationFrame(loop);
    }

    function stop() {
      running = false;
      if (raf) cancelAnimationFrame(raf);
      raf = 0;
    }

    function loop(t) {
      if (!running) return;

      if (document.hidden) {
        stop();
        return;
      }

      // FPS cap
      if (lastTick && t - lastTick < MIN_MS) {
        raf = requestAnimationFrame(loop);
        return;
      }
      lastTick = t;

      scheduleWeatherFetch(t);

      const dt = Math.min((t - (loop.last || t)) / 1000, 0.05);
      loop.last = t;

      const idle = (t - lastInteraction) / 1000;
      if (idle > 22 && !sighing) sighing = true;

      const decay = Math.exp(-idle / 8);
      const lunar = getLunar28();
      const circadianHz = getCircadianHz();

      cadenceEnergy *= Math.pow(0.001, dt / 3.2);

      const calmHz =
        circadianHz + (lunar - 0.5) * 0.1 + (weatherEnergy - 0.12) * 0.18;

      const hz = boosted
        ? BOOST_HZ
        : sighing
          ? SIGH_HZ
          : calmHz * (1 - cadenceEnergy) + cadenceHz * cadenceEnergy;

      phase += dt * hz * Math.PI * 2;

      let pulse = (Math.sin(phase) + 1) / 2;
      pulse =
        0.5 +
        (pulse - 0.5) *
          (0.96 + lunar * 0.02 + weatherEnergy * 0.01 + cadenceEnergy * 0.03);

      let spike = 0;
      if (location.pathname !== lastRoute) {
        spike = 1;
        lastRoute = location.pathname;
        touch();
      }

      writeVars(
        pulse.toFixed(4),
        decay.toFixed(4),
        phase.toFixed(4),
        spike.toFixed(2),
        lunar.toFixed(4),
      );

      raf = requestAnimationFrame(loop);
    }

    document.addEventListener(
      "visibilitychange",
      () => {
        if (!document.hidden) start();
      },
      { passive: true },
    );

    window.__pulse = { __mounted: true, touch, setBoost };

    writeVars("0.5", "1.0", "0", "0", getLunar28().toFixed(4));
    start();
  })();
</script>
