---
/* Nelumbo
Rose Lotus
Nelumbo is a component that displays a carousel of petals.
*/
import Orb from "@components/Orb.astro";
const { posts } = Astro.props;
---

<div class="carousel-layer" id="petal-shell">
  <div class="carousel-viewport">
    <div class="carousel-ring" id="petal-ring">
      {
        posts.map((post, i) => (
          <div
            class="carousel-item"
            tabindex="0"
            data-index={i}
            data-href={`/petals/${post.slug}`}
          >
            <div class="parallax-layer">
              <div class="petal-surface">
                <Orb post={post} />

                <div class="petal-content">
                  <h3>{post.data.title}</h3>
                  <p>{post.data.description}</p>
                </div>
              </div>
            </div>
          </div>
        ))
      }
    </div>
  </div>

  <div class="carousel-hint" aria-hidden="true">
    <!--  -->
  </div>
</div>

<script>
  const shell = document.getElementById("petal-shell");
  const ring = document.getElementById("petal-ring");
  const items = [...ring.querySelectorAll(".carousel-item")];

  const viewport = shell.querySelector(".carousel-viewport");

  const count = items.length;
  const step = 360 / count;
  // E.T. Phone Home
  const onHome = location.pathname === "/";
  if (onHome) {
    shell.addEventListener(
      "click",
      (e) => {
        e.preventDefault();
        e.stopPropagation();
      },
      true,
    );
  }

  /* ───────── VISIBILITY STATE ───────── */

  let petalsOpen = false;

  function updatePetalVisibility() {
    shell.toggleAttribute("data-petals-open", petalsOpen);

    if (!petalsOpen) {
      focusedIndex = -1;
    }
  }

  /* ───────── Event Listeners  ───────── */
  window.addEventListener("gesture:close-petals", () => {
    isPulling = false;
    pullVel = 0;
    petalsOpen = false;
    updatePetalVisibility();
  });

  // Esc - And Touch/Click outside of viewport to Close
  window.addEventListener("keydown", (e) => {
    if (e.key !== "Escape") return;

    if (isRevealed) {
      closeRevealedPetal();
      return;
    }

    if (petalsOpen) {
      isPulling = false;
      pullVel = 0;
      petalsOpen = false;
      updatePetalVisibility();
    }
  });

  // Touch / click outside viewport to close
  window.addEventListener(
    "pointerdown",
    (e) => {
      // If clicking inside active petal, ignore
      if (e.target.closest(".carousel-item.active")) return;

      if (isRevealed) {
        closeRevealedPetal();
        return;
      }

      if (petalsOpen) {
        isPulling = false;
        pullVel = 0;
        petalsOpen = false;
        updatePetalVisibility();
      }
    },
    { passive: true },
  );

  /* ───────────────── BASE PHYSICS ───────────────── */
  const BASE_FRICTION = 0.96;
  const BASE_SNAP = 0.06;
  const velClamp = 3.2;
  const settleThreshold = 0.015;

  /* ───────────────── STATE ───────────────── */

  let isRevealed = false;
  const REVEAL_THRESHOLD = 96; // px upward pull

  let angle = 0;
  let vel = 0;
  let isDragging = false;

  let lastAngle = null;
  let lastActive = -1;

  let focusedIndex = -1;
  let snapTarget = null;
  let snapElastic = 0;

  let rafId = 0;
  let running = false;

  const KEY_PULL_STEP = 14;
  const KEY_PULL_MAX = 140;

  // ── ACTIVE PETAL OUTWARD PULL ──
  let pullZ = 0; // current outward pull (px)
  let pullVel = 0;
  let isPulling = false;

  function closeRevealedPetal() {
    if (!isRevealed) return;

    isRevealed = false;
    isPulling = false;
    pullZ = 0;
    pullVel = 0;

    shell.removeAttribute("data-revealed");

    start(); // resume carousel physics
  }

  /* ───────────────── OM PULSE (GLOBAL) ───────────────── */
  function getOmPulse() {
    const v = getComputedStyle(document.documentElement).getPropertyValue(
      "--pulse",
    );
    const p = Number(v);
    return Number.isFinite(p) ? p : 0.5;
  }

  /* ───────────────── RADIUS (CACHED) ───────────────── */
  let radius = 300;
  const mq = matchMedia("(max-width: 768px)");

  function updateRadius() {
    radius = mq.matches ? 220 : 300;
  }
  mq.addEventListener("change", updateRadius);
  updateRadius();

  /* ───────────────── HELPERS ───────────────── */
  const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
  const snapAngle = (a) => Math.round(a / step) * step;

  function snapToIndex(index, immediate = false) {
    const target = -index * step;
    snapTarget = target;

    if (immediate) {
      angle = target;
      vel = 0;
      snapElastic = 0;
      applyTransforms();
      start();
      return;
    }

    // Small elastic offset (visual only)
    const delta = target - angle;
    snapElastic = clamp(delta * 0.12, -18, 18);

    // Kill existing spin and let snap logic handle it
    vel = 0;

    start();
  }

  /* ───────────────── TRANSFORMS ───────────────── */
  function applyTransforms() {
    if (angle === lastAngle) return;
    lastAngle = angle;

    const om = getOmPulse(); // ← HERE

    ring.style.transform = `rotateY(${angle + snapElastic}deg)`;

    const normalized = ((angle % 360) + 360) % 360;
    const active = ((Math.round(-normalized / step) % count) + count) % count;

    if (active !== lastActive) {
      lastActive = active;
      items.forEach((el, i) => el.classList.toggle("active", i === active));
    }

    const maxDist = Math.floor(count / 2 || 1);

    items.forEach((el, i) => {
      let dist = Math.abs(i - active);
      dist = Math.min(dist, count - dist);

      const depth = Math.min(1, dist / maxDist);
      const prox = 1 - depth;

      el.style.opacity = 1 - depth * 0.7;
      el.style.setProperty("--petal-depth", depth.toFixed(4));
      el.style.setProperty("--petal-prox", prox.toFixed(4));
      el.style.setProperty("--panel-scale", (1 - depth * 0.12).toFixed(4));

      const activeBias = i === active ? 22 + (om - 0.5) * 10 : 0;

      const pull = i === active ? pullZ : 0;

      el.style.transform = `translate(-50%, -50%)
         rotateY(${i * step}deg)
         translateZ(${radius + activeBias + pull}px)`;
    });
  }

  /* ───────────────── RAF LOOP (IDLE-AWARE + OM-SYNCED) ───────────────── */
  function tick() {
    if (!running) return;

    // Om pulse coupling (subtle, symmetric)
    const om = getOmPulse(); // 0..1
    const breath = (om - 0.5) * 2; // -1..+1

    const friction = BASE_FRICTION * (1 - breath * 0.015);
    const snapStrength = BASE_SNAP * (1 + breath * 0.06);

    if (!isRevealed) {
      angle += vel;
      vel *= friction;
    } else {
      vel = 0;
      angle = snapAngle(angle);
    }

    // ── SNAP TARGET RESOLUTION ──
    if (snapTarget !== null) {
      const d = snapTarget - angle;

      angle += d * snapStrength;

      // decay elastic
      snapElastic *= 0.78;

      // snap complete → hard lock
      if (Math.abs(d) < 0.01 && Math.abs(snapElastic) < 0.2) {
        angle = snapTarget;
        vel = 0;
        snapElastic = 0;
        snapTarget = null;
      }
    }

    // ── OUTWARD PULL RELAXATION ──
    if (!isPulling) {
      pullVel *= 0.82;
      pullZ += pullVel;

      pullZ += (0 - pullZ) * 0.12;

      // ── REVEAL STATE ──
      if (!isRevealed && pullZ >= REVEAL_THRESHOLD) {
        isRevealed = true;
        pullVel = 0;
        vel = 0;
        shell.setAttribute("data-revealed", "");
      }

      if (isRevealed && pullZ < REVEAL_THRESHOLD * 0.6) {
        isRevealed = false;
        shell.removeAttribute("data-revealed");
      }

      if (Math.abs(pullZ) < 0.2) {
        pullZ = 0;
        pullVel = 0;
      }
    }

    if (snapTarget === null && Math.abs(vel) < settleThreshold) {
      const snapped = snapAngle(angle);
      angle += (snapped - angle) * snapStrength;

      if (Math.abs(snapped - angle) < 0.001) {
        angle = snapped;
        vel = 0;
        running = false;
        applyTransforms();
        return;
      }
    }

    applyTransforms();
    rafId = requestAnimationFrame(tick);
  }

  function start() {
    if (running) return;
    running = true;
    rafId = requestAnimationFrame(tick);
  }

  // ── ACTIVE PETAL OUTWARD DRAG ─
  //

  /* ───────────────── INPUT ───────────────── */

  function ensureOpen() {
    if (!petalsOpen) {
      petalsOpen = true;
      updatePetalVisibility();
      start(); // kick the loop once
    }
  }

  shell.addEventListener(
    "pointermove",
    (e) => {
      if (!isDragging) return;

      // horizontal drag → rotate carousel (disabled while pulling)
      if (!isPulling) {
        vel = clamp(e.movementX * 0.12, -velClamp, velClamp);
        angle += e.movementX * 0.12;
      }

      // vertical drag → pull active petal outward
      if (e.movementY < -1) {
        isPulling = true;
      }

      if (isPulling) {
        pullVel = clamp(-e.movementY * 0.6, -8, 14);
        pullZ = clamp(pullZ + pullVel, 0, 140);
      }

      start();
    },
    { passive: true },
  );

  shell.addEventListener(
    "pointerup",
    () => {
      isDragging = false;
      isPulling = false;
    },
    { passive: true },
  );

  // Expansion

  // ── PETAL KEYBOARD CONTROLS ──
  items.forEach((el) => {
    const href = el.dataset.href;
    const index = Number(el.dataset.index);

    // Touch/click: snap this petal to focus + make it active
    el.addEventListener(
      "pointerdown",
      (e) => {
        if (e.pointerType === "mouse" && e.button !== 0) return;

        e.preventDefault();
        e.stopPropagation();

        ensureOpen();

        focusedIndex = index;
        snapToIndex(index, false);

        isDragging = true;
        isPulling = false;
        pullVel = 0;

        el.setPointerCapture?.(e.pointerId);

        start();
      },
      { passive: false },
    );

    // Keyboard
    el.addEventListener("keydown", (e) => {
      // Navigate
      if (e.key === "Enter") {
        location.href = href;
        return;
      }

      // Expand / collapse
      if (e.key === " ") {
        e.preventDefault();
        isPulling = !isPulling;
        pullVel = 0;
        start();
        return;
      }

      // Fine depth control
      if (e.key === "ArrowUp") {
        e.preventDefault();
        pullZ = clamp(pullZ + KEY_PULL_STEP, 0, KEY_PULL_MAX);
        isPulling = true;
        start();
        return;
      }

      if (e.key === "ArrowDown") {
        e.preventDefault();
        pullZ = clamp(pullZ - KEY_PULL_STEP, 0, KEY_PULL_MAX);
        if (pullZ === 0) isPulling = false;
        start();
        return;
      }

      // Collapse
      if (e.key === "Escape") {
        isPulling = false;
        pullVel = 0;
        start();
      }
    });
  });

  /* ───────────────── INIT ───────────────── */
  applyTransforms();
  updatePetalVisibility();

  /* ───────────────── CLEANUP (ASTRO ROUTES) ───────────────── */
  function cleanup() {
    closeRevealedPetal();
    cancelAnimationFrame(rafId);
    mq.removeEventListener("change", updateRadius);
  }

  window.addEventListener("astro:before-swap", cleanup);

  document.addEventListener("visibilitychange", () => {
    if (document.hidden) closeRevealedPetal();
  });
</script>

<style>
  .carousel-layer,
  .carousel-viewport,
  .carousel-ring {
    background: transparent;
    border: none;
  }

  .carousel-layer {
    position: fixed;
    inset: 0;
    pointer-events: auto;
    z-index: 6;
    isolation: isolate;
  }

  .carousel-viewport {
    pointer-events: auto;
    position: absolute;
    left: 50%;
    top: 50%;
    /*top: var(--qi-center-y);*/
    transform: translate(-50%, -50%);

    width: clamp(220px, 40vw, 320px);
    height: clamp(220px, 40vw, 320px);

    perspective: 1200px;
  }

  .carousel-ring {
    width: 100%;
    height: 100%;
    transform-style: preserve-3d;
    will-change: transform;
  }
  /*Items*/
  .carousel-item {
    position: absolute;
    left: 50%;
    top: 50%;

    width: clamp(180px, 32vw, 240px);
    aspect-ratio: 1 / 1;

    border-radius: 50%;
    overflow: visible;
    /*background: none;
    border: none;*/

    pointer-events: auto;
    will-change: transform, opacity;
  }

  /* Inner content stays inert */
  .carousel-item * {
    pointer-events: none;
  }

  .parallax-layer {
    width: 100%;
    height: 100%;
    aspect-ratio: 1 / 1;
    transform: scale(var(--panel-scale, 1));
    transition: transform 0.15s ease;
  }

  .carousel-item.active {
    box-shadow: none;
  }

  .carousel-hint {
    pointer-events: none;
    position: absolute;
    bottom: 18px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 0.4rem;
    opacity: 0.55;
    font-size: 0.7rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
  }

  @media (max-width: 768px) {
    .carousel-viewport {
      height: 320px;
    }
  }

  /* ───────────────── PETAL CONTENT REVEAL ───────────────── */

  .carousel-item .petal-content {
    position: absolute;
    inset: 0;
    padding: 1.4rem;
    opacity: 0;
    transform: translateY(18px);
    transition:
      opacity 420ms ease,
      transform 520ms cubic-bezier(0.22, 1, 0.36, 1);
  }

  /* Orb is the interaction surface */
  .carousel-item .petal-surface {
    pointer-events: auto;
    cursor: grab;
  }

  .carousel-item.active .petal-surface {
    cursor: grab;
  }

  #petal-shell[data-revealed] .carousel-item.active .petal-surface {
    cursor: default;
  }

  #petal-shell[data-revealed] .carousel-item.active .petal-content {
    opacity: 1;
    transform: translateY(0);
    pointer-events: auto;
  }

  /* soften orb when content is open */
  #petal-shell[data-revealed] .carousel-item.active .orb-wrap {
    filter: blur(6px) brightness(0.85);
    transition: filter 420ms ease;
  }
  /* Keep visual internals inert */
  .orb-wrap,
  .orb-wrap *,
  .orb-lens,
  .orb-lens * {
    pointer-events: none;
  }
  /* ───────────────── PETAL VISIBILITY TOGGLE ───────────────── */
  /* Home page: carousel is display-only */
  body[data-route="home"] .carousel-viewport {
    pointer-events: auto;
  }

  #petal-shell {
    transition:
      opacity 420ms ease,
      transform 520ms cubic-bezier(0.2, 0.7, 0.2, 1);
  }

  #petal-shell:not([data-petals-open]) {
    opacity: 0;
    pointer-events: none;
    transform: translateY(12px) scale(0.98);
  }
</style>
