---
/* Nelumbo
Rose Lotus - Rotating LED Display.
Nelumbo is a component that displays a carousel of petals.
HUD overlay opens on double click / long press.
*/
import Orb from "@components/Orb.astro";
import type { CollectionEntry } from "astro:content";

const { posts } = Astro.props as { posts: CollectionEntry<"petals">[] };

// Pre-render post markdown bodies so HUD can display full article content.
const rendered = await Promise.all(
  posts.map(async (post) => {
    const { Content } = await post.render();

    // Extract first markdown image from raw body (same logic you used elsewhere)
    let imageSrc: string | null = null;
    const match = post.body.match(/!\[.*?\]\((.*?)\)/);
    if (match?.[1]) {
      const raw = match[1].trim();
      imageSrc =
        raw.startsWith("http") || raw.startsWith("/")
          ? raw
          : `/images/${raw.replace(/^\.?\//, "")}`;
    }

    // Date label
    const d = new Date(post.data.date);
    const dateLabel = d.toLocaleDateString(undefined, {
      month: "2-digit",
      day: "2-digit",
      year: "numeric",
    });

    // Lightweight reading time estimate (no util import needed here)
    const words = post.body.split(/\s+/).filter(Boolean).length;
    const rt = Math.max(1, Math.round(words / 200));

    return {
      slug: post.slug,
      title: post.data.title,
      description: post.data.description ?? "",
      dateLabel,
      rt,
      imageSrc,
      Content,
    };
  }),
);
---

<div class="carousel-layer" id="petal-shell">
  <div class="carousel-viewport" id="petal-viewport">
    <div class="carousel-ring" id="petal-ring">
      {
        posts.map((post, i) => (
          <div
            class="carousel-item"
            tabindex="0"
            data-index={i}
            data-href={`/petals/${post.slug}`}
            data-slug={post.slug}
          >
            <div class="parallax-layer">
              <div class="petal-surface">
                <Orb post={post} />
              </div>
            </div>
          </div>
        ))
      }
    </div>
  </div>

  {/* HUD Overlay */}
  <div class="hud" id="hud" aria-hidden="true">
    <div
      class="hud-frame"
      role="dialog"
      aria-modal="true"
      aria-label="Petal HUD"
    >
      <button class="hud-close" type="button" aria-label="Close HUD">✕</button>

      {/* Cosmetic layers */}
      <div class="hud-grid" aria-hidden="true"></div>
      <div class="hud-scan" aria-hidden="true"></div>

      {/* Content */}
      <header class="hud-head">
        <div class="hud-title" data-hud-title></div>
        <div class="hud-meta">
          <span class="hud-chip" data-hud-date></span>
          <span class="hud-chip" data-hud-rt></span>
          <span class="hud-chip hud-chip-link">
            <a data-hud-link href="#" rel="prefetch">Open</a>
          </span>
        </div>
      </header>

      <div class="hud-body">
        <aside class="hud-media">
          <div class="hud-media-frame">
            <img data-hud-img alt="" />
            <div class="hud-media-glint" aria-hidden="true"></div>
          </div>

          <div class="hud-desc" data-hud-desc></div>

          <div class="hud-readout" aria-hidden="true">
            <div class="hud-bar"></div>
            <div class="hud-bar"></div>
            <div class="hud-bar"></div>
          </div>
        </aside>

        <section class="hud-article">
          <div class="hud-article-label">TRANSMISSION</div>
          <div class="hud-article-scroll" data-hud-article></div>
        </section>
      </div>

      <footer class="hud-foot" aria-hidden="true">
        <div class="hud-corners"></div>
      </footer>
    </div>
  </div>

  {/* Hidden banks of rendered article content */}
  <div class="hud-bank" aria-hidden="true">
    {
      rendered.map((r) => (
        <div class="hud-bank-item" data-bank={r.slug}>
          <div class="prose dark:prose-invert">
            <r.Content />
          </div>
        </div>
      ))
    }
  </div>
</div>

<script is:inline>
  const shell = document.getElementById("petal-shell");
  const ring = document.getElementById("petal-ring");
  const items = ring ? [...ring.querySelectorAll(".carousel-item")] : [];
  const viewport = document.getElementById("petal-viewport");

  const hud = document.getElementById("hud");
  const hudClose = hud?.querySelector(".hud-close");

  const hudTitle = hud?.querySelector("[data-hud-title]");
  const hudDate = hud?.querySelector("[data-hud-date]");
  const hudRt = hud?.querySelector("[data-hud-rt]");
  const hudDesc = hud?.querySelector("[data-hud-desc]");
  const hudImg = hud?.querySelector("[data-hud-img]");
  const hudLink = hud?.querySelector("[data-hud-link]");
  const hudArticle = hud?.querySelector("[data-hud-article]");

  const bank = shell?.querySelector(".hud-bank");

  const count = items.length;
  const step = count ? 360 / count : 360;

  // ───────────────── BASE PHYSICS ─────────────────
  const BASE_FRICTION = 0.96;
  const BASE_SNAP = 0.06;
  const velClamp = 3.2;
  const settleThreshold = 0.015;

  // ───────────────── STATE ─────────────────
  let petalsOpen = false;
  let angle = 0;
  let vel = 0;
  let isDragging = false;

  let lastAngle = null;
  let lastActive = -1;

  let focusedIndex = -1;
  let snapTarget = null;
  let snapElastic = 0;

  let rafId = 0;
  let running = false;

  // long press / double click open HUD
  let pressTimer = 0;
  let pressStartX = 0;
  let pressStartY = 0;
  const LONG_PRESS_MS = 420;
  const MOVE_CANCEL_PX = 10;

  // ─────────── side-hide tuning ───────────
  const normDeg = (d) => ((d % 360) + 360) % 360;
  const angDist = (a, b) => {
    const d = Math.abs(a - b) % 360;
    return d > 180 ? 360 - d : d;
  };
  const smoothstep = (e0, e1, x) => {
    const t = Math.max(0, Math.min(1, (x - e0) / (e1 - e0)));
    return t * t * (3 - 2 * t);
  };
  const SIDE_KILL = 43;
  const SIDE_FADE_END = 52;

  // ───────────────── RADIUS (CACHED) ─────────────────
  let radius = 300;
  const mq = matchMedia("(max-width: 768px)");
  function updateRadius() {
    radius = mq.matches ? 220 : 300;
  }
  mq.addEventListener("change", updateRadius);
  updateRadius();

  // ───────────────── HELPERS ─────────────────
  const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
  const snapAngle = (a) => Math.round(a / step) * step;

  function getOmPulse() {
    const v = getComputedStyle(document.documentElement).getPropertyValue(
      "--pulse",
    );
    const p = Number(v);
    return Number.isFinite(p) ? p : 0.5;
  }

  function updatePetalVisibility() {
    if (!shell) return;
    shell.toggleAttribute("data-petals-open", petalsOpen);
    if (!petalsOpen) focusedIndex = -1;
  }

  function openHUDForIndex(index) {
    const el = items[index];
    if (!el || !hud || !bank) return;

    const slug = el.dataset.slug;
    const href = el.dataset.href;

    // Find corresponding bank node and pull rendered HTML
    const bankItem = bank.querySelector(`[data-bank="${slug}"]`);
    const articleHTML = bankItem ? bankItem.innerHTML : "<p>(No content)</p>";

    // Title/desc/date/rt/img are embedded server-side in data attributes? not here.
    // So we read from DOM via a small hidden dataset map populated below.
    const meta = window.__nelumbo_meta?.[slug];
    if (!meta) return;

    hudTitle.textContent = meta.title || "";
    hudDate.textContent = meta.dateLabel || "";
    hudRt.textContent = `${meta.rt || 1} min`;

    hudDesc.textContent = meta.description || "";
    hudLink.href = href || "#";

    if (meta.imageSrc) {
      hudImg.src = meta.imageSrc;
      hudImg.alt = meta.title || "Post image";
      hudImg.style.opacity = "1";
    } else {
      hudImg.removeAttribute("src");
      hudImg.alt = "";
      hudImg.style.opacity = "0";
    }

    hudArticle.innerHTML = articleHTML;

    hud.classList.add("is-open");
    hud.setAttribute("aria-hidden", "false");

    // stop carousel motion while HUD is open
    running = false;
    cancelAnimationFrame(rafId);

    // focus close for accessibility
    hudClose?.focus?.();
  }

  function closeHUD() {
    if (!hud) return;
    hud.classList.remove("is-open");
    hud.setAttribute("aria-hidden", "true");
    // resume carousel physics
    start();
  }

  hudClose?.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    closeHUD();
  });

  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape") closeHUD();
  });

  hud?.addEventListener("pointerdown", (e) => {
    // click outside the frame closes
    const frame = hud.querySelector(".hud-frame");
    if (frame && !frame.contains(e.target)) closeHUD();
  });

  function snapToIndex(index, immediate = false) {
    const target = -index * step;
    snapTarget = target;

    if (immediate) {
      angle = target;
      vel = 0;
      snapElastic = 0;
      applyTransforms();
      start();
      return;
    }

    const delta = target - angle;
    snapElastic = clamp(delta * 0.12, -18, 18);
    vel = 0;
    start();
  }

  function applyTransforms() {
    if (!ring) return;
    if (angle === lastAngle) return;
    lastAngle = angle;

    const om = getOmPulse();
    ring.style.transform = `translateZ(0) rotateY(${angle + snapElastic}deg)`;

    const normalized = normDeg(angle);
    const active = ((Math.round(-normalized / step) % count) + count) % count;

    if (active !== lastActive) {
      lastActive = active;
      items.forEach((el, i) => el.classList.toggle("active", i === active));
    }

    const maxDist = Math.floor(count / 2 || 1);

    items.forEach((el, i) => {
      let dist = Math.abs(i - active);
      dist = Math.min(dist, count - dist);

      const depth = Math.min(1, dist / maxDist);
      const prox = 1 - depth;

      el.style.setProperty("--petal-depth", depth.toFixed(4));
      el.style.setProperty("--petal-prox", prox.toFixed(4));

      const baseScale = 1 - depth * 0.12;

      // Side profile hiding (keeps 3D illusion)
      const yaw = normDeg(i * step + angle + snapElastic);
      const sideDist = Math.min(angDist(yaw, 90), angDist(yaw, 270));
      const sideVis = smoothstep(SIDE_KILL, SIDE_FADE_END, sideDist);

      const depthVis = 1 - depth * 0.7;
      const finalVis = depthVis * sideVis;

      el.style.opacity = finalVis.toFixed(3);

      const sideScale = 0.88 + 0.12 * sideVis;
      el.style.setProperty("--panel-scale", (baseScale * sideScale).toFixed(4));

      el.style.pointerEvents = sideVis < 0.08 ? "none" : "auto";
      el.style.visibility = sideVis < 0.02 ? "hidden" : "visible";

      const activeBias = i === active ? 22 + (om - 0.5) * 10 : 0;
      el.style.transform = `translate(-50%, -50%)
        rotateY(${i * step}deg)
        translateZ(${radius + activeBias}px)`;
    });
  }

  function tick() {
    if (!running) return;

    const om = getOmPulse();
    const breath = (om - 0.5) * 2;

    const friction = BASE_FRICTION * (1 - breath * 0.015);
    const snapStrength = BASE_SNAP * (1 + breath * 0.06);

    angle += vel;
    vel *= friction;

    if (snapTarget !== null) {
      const d = snapTarget - angle;
      angle += d * snapStrength;
      snapElastic *= 0.78;

      if (Math.abs(d) < 0.01 && Math.abs(snapElastic) < 0.2) {
        angle = snapTarget;
        vel = 0;
        snapElastic = 0;
        snapTarget = null;
      }
    }

    if (snapTarget === null && Math.abs(vel) < settleThreshold) {
      const snapped = snapAngle(angle);
      angle += (snapped - angle) * snapStrength;

      if (Math.abs(snapped - angle) < 0.001) {
        angle = snapped;
        vel = 0;
        running = false;
        applyTransforms();
        return;
      }
    }

    applyTransforms();
    rafId = requestAnimationFrame(tick);
  }

  function start() {
    if (hud?.classList.contains("is-open")) return;
    if (running) return;
    running = true;
    rafId = requestAnimationFrame(tick);
  }

  function ensureOpen() {
    if (!petalsOpen) {
      petalsOpen = true;
      updatePetalVisibility();
      start();
    }
  }

  // ───────────────── INPUT: drag rotate + dblclick/longpress HUD ─────────────────
  function clearPressTimer() {
    if (pressTimer) {
      clearTimeout(pressTimer);
      pressTimer = 0;
    }
  }

  items.forEach((el) => {
    const index = Number(el.dataset.index);

    el.addEventListener(
      "pointerdown",
      (e) => {
        if (e.pointerType === "mouse" && e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();

        ensureOpen();
        focusedIndex = index;
        snapToIndex(index, false);

        isDragging = true;
        pressStartX = e.clientX;
        pressStartY = e.clientY;

        clearPressTimer();
        pressTimer = setTimeout(() => {
          // long press open HUD for active/focused
          openHUDForIndex(index);
        }, LONG_PRESS_MS);

        el.setPointerCapture?.(e.pointerId);
        start();
      },
      { passive: false },
    );

    el.addEventListener(
      "pointermove",
      (e) => {
        if (!isDragging) return;

        const dx = e.clientX - pressStartX;
        const dy = e.clientY - pressStartY;

        // if user moves too much, cancel long-press
        if (Math.hypot(dx, dy) > MOVE_CANCEL_PX) clearPressTimer();

        // drag rotates carousel
        vel = clamp(e.movementX * 0.12, -velClamp, velClamp);
        angle += e.movementX * 0.12;

        start();
      },
      { passive: true },
    );

    el.addEventListener(
      "pointerup",
      () => {
        isDragging = false;
        clearPressTimer();
      },
      { passive: true },
    );

    el.addEventListener("dblclick", (e) => {
      e.preventDefault();
      e.stopPropagation();
      openHUDForIndex(index);
    });

    el.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        openHUDForIndex(index);
      }
      if (e.key === "Escape") {
        closeHUD();
      }
    });
  });

  // close petals if clicking outside viewport
  window.addEventListener(
    "pointerdown",
    (e) => {
      if (!viewport) return;
      if (hud?.classList.contains("is-open")) return;

      if (!viewport.contains(e.target)) {
        petalsOpen = false;
        updatePetalVisibility();
      }
    },
    { passive: true },
  );

  // initial
  applyTransforms();
  updatePetalVisibility();

  // cleanup
  function cleanup() {
    clearPressTimer();
    cancelAnimationFrame(rafId);
    mq.removeEventListener("change", updateRadius);
  }
  window.addEventListener("astro:before-swap", cleanup);

  // Server-generated meta map (slug -> key info)
  // (Populated by Astro below)
  window.__nelumbo_meta = window.__nelumbo_meta || {};
</script>

<script is:inline define:vars={{ rendered }}>
  // Populate the meta map from server-side data (safe + fast)
  window.__nelumbo_meta = window.__nelumbo_meta || {};
  for (const r of rendered) {
    window.__nelumbo_meta[r.slug] = {
      slug: r.slug,
      title: r.title,
      description: r.description,
      dateLabel: r.dateLabel,
      rt: r.rt,
      imageSrc: r.imageSrc,
    };
  }
</script>

<style>
  .carousel-layer,
  .carousel-viewport,
  .carousel-ring {
    background: transparent;
    border: none;
  }

  .carousel-layer {
    position: fixed;
    inset: 0;
    pointer-events: auto;
    z-index: 6;
    isolation: isolate;
  }

  /* Keep carousel perfectly centered, stable, and as the 3D anchor */
  .carousel-viewport {
    pointer-events: auto;
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: clamp(220px, 40vw, 320px);
    height: clamp(220px, 40vw, 320px);
    perspective: 1200px;
    transform-style: preserve-3d;
  }

  .carousel-ring {
    width: 100%;
    height: 100%;
    transform-style: preserve-3d;
    will-change: transform;
  }

  .carousel-item {
    position: absolute;
    left: 50%;
    top: 50%;
    width: clamp(180px, 32vw, 240px);
    aspect-ratio: 1 / 1;
    border-radius: 50%;
    overflow: visible;
    will-change: transform, opacity;
    transform-style: preserve-3d;
    contain: layout paint;
  }

  .parallax-layer {
    width: 100%;
    height: 100%;
    aspect-ratio: 1 / 1;
    transform: translateZ(0) scale(var(--panel-scale, 1));
    transition: transform 0.15s ease;
    display: grid;
    place-items: center;
    transform-origin: 50% 50%;
  }

  .carousel-item .petal-surface {
    width: 100%;
    height: 100%;
    display: grid;
    place-items: center;
    aspect-ratio: 1 / 1;
    cursor: grab;
    pointer-events: auto;
  }

  .carousel-item * {
    pointer-events: none;
  }

  /* Hide banks */
  .hud-bank {
    position: absolute;
    width: 1px;
    height: 1px;
    overflow: hidden;
    opacity: 0;
    pointer-events: none;
  }

  /* ───────────────── HUD Overlay (cyber HUD, not modal) ───────────────── */
  .hud {
    position: fixed;
    inset: 0;
    z-index: 50;
    pointer-events: none;
    opacity: 0;
    transition: opacity 200ms ease;
  }

  .hud.is-open {
    opacity: 1;
    pointer-events: auto;
  }

  .hud-frame {
    position: absolute;
    left: 50%;
    top: 50%;
    width: min(980px, calc(100vw - 32px));
    height: min(620px, calc(100vh - 36px));
    transform: translate(-50%, -50%);
    border-radius: 18px;

    background: color-mix(in oklch, black 35%, transparent);
    border: 1px solid color-mix(in oklch, currentColor 20%, transparent);

    backdrop-filter: blur(14px);
    -webkit-backdrop-filter: blur(14px);

    box-shadow:
      0 0 0 1px color-mix(in oklch, currentColor 10%, transparent) inset,
      0 30px 90px color-mix(in oklch, black 70%, transparent);

    overflow: hidden;
  }

  .hud-close {
    all: unset;
    position: absolute;
    right: 14px;
    top: 12px;
    width: 34px;
    height: 34px;
    display: grid;
    place-items: center;
    border-radius: 10px;
    cursor: pointer;
    color: currentColor;

    background: color-mix(in oklch, black 25%, transparent);
    border: 1px solid color-mix(in oklch, currentColor 18%, transparent);
    transition:
      transform 160ms ease,
      background 160ms ease;
    z-index: 5;
  }

  .hud-close:hover {
    transform: scale(1.04);
    background: color-mix(in oklch, black 35%, transparent);
  }

  .hud-grid {
    position: absolute;
    inset: 0;
    background:
      linear-gradient(
        to right,
        color-mix(in oklch, currentColor 12%, transparent) 1px,
        transparent 1px
      ),
      linear-gradient(
        to bottom,
        color-mix(in oklch, currentColor 10%, transparent) 1px,
        transparent 1px
      );
    background-size: 44px 44px;
    opacity: 0.28;
    mask-image: radial-gradient(circle at 50% 50%, black 55%, transparent 80%);
    pointer-events: none;
  }

  .hud-scan {
    position: absolute;
    inset: -40% 0;
    background: linear-gradient(
      to bottom,
      transparent,
      color-mix(in oklch, currentColor 20%, transparent),
      transparent
    );
    opacity: 0.25;
    animation: hudScan 2.6s linear infinite;
    pointer-events: none;
    mix-blend-mode: screen;
  }

  @keyframes hudScan {
    from {
      transform: translateY(-30%);
    }
    to {
      transform: translateY(30%);
    }
  }

  .hud-head {
    position: relative;
    padding: 18px 18px 12px;
    display: flex;
    align-items: flex-end;
    justify-content: space-between;
    gap: 16px;
    z-index: 2;
  }

  .hud-title {
    font-size: 1.05rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    opacity: 0.9;
    max-width: 70%;
    line-height: 1.2;
  }

  .hud-meta {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: flex-end;
  }

  .hud-chip {
    font-size: 0.72rem;
    opacity: 0.78;
    padding: 6px 10px;
    border-radius: 999px;
    border: 1px solid color-mix(in oklch, currentColor 18%, transparent);
    background: color-mix(in oklch, black 18%, transparent);
    text-transform: uppercase;
    letter-spacing: 0.06em;
  }

  .hud-chip-link a {
    color: currentColor;
    text-decoration: none;
  }

  .hud-body {
    display: grid;
    grid-template-columns: 320px 1fr;
    gap: 16px;
    padding: 10px 18px 18px;
    height: calc(100% - 62px);
    position: relative;
    z-index: 2;
  }

  .hud-media {
    display: flex;
    flex-direction: column;
    gap: 12px;
    min-width: 0;
  }

  .hud-media-frame {
    position: relative;
    border-radius: 14px;
    overflow: hidden;
    border: 1px solid color-mix(in oklch, currentColor 18%, transparent);
    background: color-mix(in oklch, black 25%, transparent);
    height: 220px;
  }

  .hud-media-frame img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    filter: contrast(1.08) saturate(1.06);
  }

  .hud-media-glint {
    position: absolute;
    inset: -40% -40%;
    background: linear-gradient(
      120deg,
      transparent 20%,
      color-mix(in oklch, currentColor 16%, transparent) 50%,
      transparent 80%
    );
    opacity: 0.35;
    animation: glint 3.6s linear infinite;
    mix-blend-mode: screen;
  }

  @keyframes glint {
    from {
      transform: translateX(-20%) translateY(-10%) rotate(10deg);
    }
    to {
      transform: translateX(20%) translateY(10%) rotate(10deg);
    }
  }

  .hud-desc {
    font-size: 0.9rem;
    line-height: 1.35;
    opacity: 0.82;
    padding: 10px 12px;
    border-radius: 14px;
    border: 1px dashed color-mix(in oklch, currentColor 18%, transparent);
    background: color-mix(in oklch, black 14%, transparent);
    max-height: 120px;
    overflow: auto;
  }

  .hud-readout {
    display: grid;
    gap: 8px;
    opacity: 0.6;
  }

  .hud-bar {
    height: 10px;
    border-radius: 999px;
    background: linear-gradient(
      to right,
      color-mix(in oklch, currentColor 25%, transparent),
      transparent
    );
    overflow: hidden;
    position: relative;
  }

  .hud-bar::after {
    content: "";
    position: absolute;
    inset: 0;
    background: linear-gradient(
      to right,
      transparent,
      color-mix(in oklch, currentColor 22%, transparent),
      transparent
    );
    transform: translateX(-60%);
    animation: barSweep 1.8s linear infinite;
  }

  @keyframes barSweep {
    to {
      transform: translateX(60%);
    }
  }

  .hud-article {
    min-width: 0;
    border-radius: 14px;
    border: 1px solid color-mix(in oklch, currentColor 18%, transparent);
    background: color-mix(in oklch, black 12%, transparent);
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  .hud-article-label {
    font-size: 0.72rem;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    opacity: 0.7;
    padding: 10px 12px;
    border-bottom: 1px solid color-mix(in oklch, currentColor 12%, transparent);
  }

  .hud-article-scroll {
    padding: 12px 14px 18px;
    overflow: auto;
    height: 100%;
  }

  /* Make prose readable inside HUD */
  .hud-article-scroll :global(p),
  .hud-article-scroll :global(li) {
    line-height: 1.5;
  }

  .hud-article-scroll :global(h1),
  .hud-article-scroll :global(h2),
  .hud-article-scroll :global(h3) {
    margin-top: 1.1em;
  }

  /* Responsive */
  @media (max-width: 860px) {
    .hud-body {
      grid-template-columns: 1fr;
    }
    .hud-media-frame {
      height: 200px;
    }
  }

  /* Petal visibility toggle */
  #petal-shell {
    transition:
      opacity 420ms ease,
      transform 520ms cubic-bezier(0.2, 0.7, 0.2, 1);
  }

  #petal-shell:not([data-petals-open]) {
    opacity: 0;
    pointer-events: none;
    transform: translateY(12px) scale(0.98);
  }
</style>
