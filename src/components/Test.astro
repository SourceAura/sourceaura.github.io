---
/**
 * Test.astro
 */
const {
  width = 720,
  height = 416,

  sphereRad = 111,
  radiusSp = 1,
  particlesPerFrame = 9,

  // Glow tuning (dark mode only)
  glowBlur = 9,
  glowStrength = 0.55, // alpha multiplier in dark mode
} = Astro.props;

const uid = `ps_${Math.random().toString(16).slice(2)}`;
const canvasId = `${uid}_canvas`;
---

<div class="ps-wrap" data-ps-root={uid}>
  <canvas id={canvasId} width={width} height={height}></canvas>
</div>

<script
  is:inline
  define:vars={{
    uid,
    canvasId,
    sphereRad,
    radiusSp,
    particlesPerFrame,
    glowBlur,
    glowStrength,
  }}
>
  (() => {
    window.__plasmaSphereMounted ??= new Set();
    if (window.__plasmaSphereMounted.has(uid)) return;
    window.__plasmaSphereMounted.add(uid);

    const canvas = document.getElementById(canvasId);
    const ctx = canvas?.getContext("2d"); // transparent background
    if (!canvas || !ctx) return;

    const reduceMotion = matchMedia("(prefers-reduced-motion: reduce)").matches;

    const displayWidth = canvas.width;
    const displayHeight = canvas.height;

    const fLen = 320;
    const projCenterX = displayWidth / 2;
    const projCenterY = displayHeight / 2;
    const zMax = fLen - 2;

    const particleRad = 1.6;
    const particleAlpha = 1;

    const randAccelX = 0.1;
    const randAccelY = 0.1;
    const randAccelZ = 0.1;
    const gravity = -0;

    const zeroAlphaDepth = -750;

    const turnSpeed = (2 * Math.PI) / 1200;
    let turnAngle = 0;

    const particleList = { first: null };
    const recycleBin = { first: null };

    const sphereCenterX = 0;
    const sphereCenterY = 0;
    const sphereCenterZ = () => -3 - sphereRad;

    let raf = 0;

    // Read compositing + rgb from CSS (theme + currentColor driven)
    function getRenderStyle() {
      const rootStyle = getComputedStyle(document.documentElement);
      const wrap = document.querySelector(`[data-ps-root="${uid}"]`);
      const wrapStyle = wrap ? getComputedStyle(wrap) : rootStyle;

      // currentColor captured as rgb string like "rgb(0, 0, 0)"
      const c = wrapStyle.color;
      // Extract numbers -> "r,g,b"
      const m = c.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
      const rgb = m ? `${m[1]},${m[2]},${m[3]}` : "0,0,0";

      const mode = rootStyle.getPropertyValue("--ps-composite-mode").trim();
      const glow = rootStyle.getPropertyValue("--ps-glow").trim(); // "on" | "off"

      return { rgb, mode: mode || "source-over", glow: glow || "off" };
    }

    function addParticle(x0, y0, z0, vx0, vy0, vz0) {
      let p = recycleBin.first || {};
      if (recycleBin.first) {
        recycleBin.first = p.next;
        if (p.next) p.next.prev = null;
      }

      p.next = particleList.first;
      if (particleList.first) particleList.first.prev = p;
      particleList.first = p;
      p.prev = null;

      p.x = x0;
      p.y = y0;
      p.z = z0;
      p.velX = vx0;
      p.velY = vy0;
      p.velZ = vz0;
      p.age = 0;
      p.dead = false;

      // envelope
      p.attack = 50;
      p.hold = 50;
      p.decay = 100;
      p.initValue = 0;
      p.holdValue = particleAlpha;
      p.lastValue = 0;
      p.stuckTime = 90 + Math.random() * 20;

      p.accelX = 0;
      p.accelY = gravity;
      p.accelZ = 0;

      return p;
    }

    function recycle(p) {
      if (particleList.first === p) {
        particleList.first = p.next;
        if (p.next) p.next.prev = null;
      } else {
        if (p.prev) p.prev.next = p.next;
        if (p.next) p.next.prev = p.prev;
      }

      p.next = recycleBin.first;
      if (recycleBin.first) recycleBin.first.prev = p;
      recycleBin.first = p;
      p.prev = null;
    }

    function spawn() {
      for (let i = 0; i < particlesPerFrame; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(Math.random() * 2 - 1);

        const x0 = sphereRad * Math.sin(phi) * Math.cos(theta);
        const y0 = sphereRad * Math.sin(phi) * Math.sin(theta);
        const z0 = sphereRad * Math.cos(phi);

        addParticle(
          x0,
          sphereCenterY + y0,
          sphereCenterZ() + z0,
          0.007 * x0,
          0.007 * y0,
          0.007 * z0,
        );
      }
    }

    function draw() {
      spawn();

      turnAngle = (turnAngle + turnSpeed) % (Math.PI * 2);
      const sinA = Math.sin(turnAngle);
      const cosA = Math.cos(turnAngle);

      // Transparent background
      ctx.clearRect(0, 0, displayWidth, displayHeight);

      // Theme-based render settings
      const { rgb, mode, glow } = getRenderStyle();
      ctx.globalCompositeOperation = mode;

      // Dark-only glow
      if (glow === "on") {
        ctx.shadowBlur = glowBlur;
        ctx.shadowColor = `rgba(${rgb}, 0.85)`;
      } else {
        ctx.shadowBlur = 0;
        ctx.shadowColor = "transparent";
      }

      let p = particleList.first;
      while (p) {
        const next = p.next;
        p.age++;

        if (p.age > p.stuckTime) {
          p.velX += p.accelX + randAccelX * (Math.random() * 2 - 1);
          p.velY += p.accelY + randAccelY * (Math.random() * 2 - 1);
          p.velZ += p.accelZ + randAccelZ * (Math.random() * 2 - 1);
          p.x += p.velX;
          p.y += p.velY;
          p.z += p.velZ;
        }

        const scz = sphereCenterZ();
        const rotX = cosA * p.x + sinA * (p.z - scz);
        const rotZ = -sinA * p.x + cosA * (p.z - scz) + scz;

        const m = (radiusSp * fLen) / (fLen - rotZ);
        const px = rotX * m + projCenterX;
        const py = p.y * m + projCenterY;

        // Cull
        if (
          px < 0 ||
          px > displayWidth ||
          py < 0 ||
          py > displayHeight ||
          rotZ > zMax
        ) {
          recycle(p);
          p = next;
          continue;
        }

        // Alpha envelope
        if (p.age < p.attack + p.hold + p.decay) {
          if (p.age < p.attack) p.alpha = (p.holdValue / p.attack) * p.age;
          else if (p.age < p.attack + p.hold) p.alpha = p.holdValue;
          else {
            p.alpha =
              ((p.lastValue - p.holdValue) / p.decay) *
                (p.age - p.attack - p.hold) +
              p.holdValue;
          }
        } else {
          recycle(p);
          p = next;
          continue;
        }

        // Depth darkening
        let depth = 1 - rotZ / zeroAlphaDepth;
        depth = Math.max(0, Math.min(1, depth));

        // Dark mode glow looks nicer with a bit more opacity; light mode multiply should stay crisp.
        const alphaBoost = glow === "on" ? glowStrength : 1;
        ctx.fillStyle = `rgba(${rgb}, ${depth * p.alpha * alphaBoost})`;

        ctx.beginPath();
        ctx.arc(px, py, m * particleRad, 0, Math.PI * 2);
        ctx.fill();

        p = next;
      }

      // Reset composite so other canvases don’t inherit it (paranoia = good)
      ctx.globalCompositeOperation = "source-over";

      raf = requestAnimationFrame(draw);
    }

    if (!reduceMotion) draw();

    window.addEventListener(
      "astro:before-swap",
      () => {
        cancelAnimationFrame(raf);
        window.__plasmaSphereMounted.delete(uid);
      },
      { once: true },
    );
  })();
</script>

<style>
  .ps-wrap {
    display: flex;
    justify-content: center;

    /* The orb inherits color from its parent by default */
    color: inherit;
  }

  canvas {
    display: block;
    max-width: 100%;
    height: auto;
    background: transparent;
  }

  /* ThemeSwitch: define render behavior at the document level */
  :global(html.dark) {
    --ps-composite-mode: lighter; /* glow-friendly additive */
    --ps-glow: on;

    /* If you want explicit control, you can also set a color here:
       color: white;  (but usually you’ll set color on the parent section) */
  }

  :global(html.light) {
    --ps-composite-mode: multiply; /* ink-like */
    --ps-glow: off;

    /* Same note: you can set color on the parent if desired */
  }
</style>
