<div id="qi-root">
  <canvas id="qi-vis"></canvas>
</div>

<style>
  #qi-root {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 0;
  }

  #qi-vis {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
  }
</style>

<script>
  const canvas = document.getElementById("qi-vis");
  const ctx = canvas.getContext("2d");

  const BINS = 240;
  const audio = new Float32Array(BINS);

  let isLight = false;
  let cssW = 0;
  let cssH = 0;

  const prefersReduced = matchMedia("(prefers-reduced-motion: reduce)").matches;

  /* ───────────────── THEME ───────────────── */
  function updateTheme() {
    isLight = document.documentElement.classList.contains("light");
  }
  updateTheme();
  new MutationObserver(updateTheme).observe(document.documentElement, {
    attributes: true,
    attributeFilter: ["class"],
  });

  /* ───────────────── RESIZE ───────────────── */
  function resize() {
    const dpr = Math.min(devicePixelRatio || 1, 2);
    const rect = canvas.getBoundingClientRect();
    cssW = rect.width;
    cssH = rect.height;
    canvas.width = cssW * dpr;
    canvas.height = cssH * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  resize();
  addEventListener("resize", resize);
  addEventListener("orientationchange", resize);

  /* ───────────────── AUDIO MOCK ───────────────── */
  function updateAudio() {
    for (let i = 0; i < audio.length; i++) {
      audio[i] = Math.max(
        0.02,
        Math.min(1, audio[i] + (Math.random() - 0.5) * 0.02),
      );
    }
  }

  /* ───────────────── OM ENTRAINMENT ───────────────── */
  function getOmPulse() {
    const v = getComputedStyle(document.documentElement).getPropertyValue(
      "--pulse",
    );
    return Number(v) || 0.5;
  }

  /* ───────────────── WAKE STATE ───────────────── */
  let wake = 0;
  function setWake(on) {
    wake += on ? 0.25 : -0.12;
    wake = Math.max(0, Math.min(1, wake));
  }
  window.addEventListener("open-pagefind", () => setWake(true));
  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape") setWake(false);
  });

  /* ───────────────── SESSION MEMORY ───────────────── */
  const PHASE_KEY = "qi-neural-phase";
  let sessionPhase =
    Number(localStorage.getItem(PHASE_KEY)) || Math.random() * Math.PI * 2;
  setInterval(() => {
    localStorage.setItem(PHASE_KEY, sessionPhase.toFixed(4));
  }, 5000);

  /* ───────────────── NEURAL CORE ───────────────── */
  const NODES = 21;
  const LINKS = [];
  const FIRINGS = [];
  const RIPPLES = [];

  const nodes = Array.from({ length: NODES }, (_, i) => ({
    a: Math.random() * Math.PI * 2,
    s: 0.001 + Math.random() * 0.0015,
    bin: Math.floor((i / NODES) * BINS),
  }));

  for (let i = 0; i < NODES; i++) {
    for (let j = i + 1; j < NODES; j++) {
      if (Math.random() < 0.2) LINKS.push([i, j]);
    }
  }

  function maybeFire() {
    if (Math.random() < 0.02 + wake * 0.04) {
      const link = LINKS[Math.floor(Math.random() * LINKS.length)];
      FIRINGS.push({ link, t: 0 });
    }
  }

  /* ───────────────── CEPHALON CORE ───────────────── */
  const CEPHALON_POINTS = 64;
  const cephalon = Array.from({ length: CEPHALON_POINTS }, (_, i) => ({
    a: (i / CEPHALON_POINTS) * Math.PI * 2,
    r: 0.35 + Math.random() * 0.25,
    s: 0.0006 + Math.random() * 0.0006,
    p: Math.random() * Math.PI * 2,
  }));

  function drawCephalonCore(radius) {
    const pulse = getOmPulse();
    const t = performance.now() * 0.001;

    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.lineWidth = 0.6;

    const base = isLight ? 0 : 255;
    const alpha = 0.06 + wake * 0.08 + pulse * 0.06;

    ctx.strokeStyle = `rgba(${base},${base},${base},${alpha})`;

    for (let i = 0; i < cephalon.length; i++) {
      const p1 = cephalon[i];
      const p2 = cephalon[(i + 1) % cephalon.length];

      p1.a += p1.s * (0.6 + pulse);
      p1.p += 0.003 + wake * 0.004;

      const snap = Math.sin(p1.a * 6) * 0.015 * wake;
      const warp =
        Math.sin(p1.p + t) * 0.08 + Math.sin(p1.a * 3 + t * 0.7) * 0.05 + snap;

      const r1 = radius * (p1.r + warp);
      const r2 = radius * (p2.r + warp * 0.7);

      const x1 = Math.cos(p1.a + sessionPhase) * r1;
      const y1 = Math.sin(p1.a + sessionPhase) * r1;
      const x2 = Math.cos(p2.a + sessionPhase) * r2;
      const y2 = Math.sin(p2.a + sessionPhase) * r2;

      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    ctx.restore();
  }

  /* ───────────────── MERKABA ───────────────── */
  function drawMerkaba(radius) {
    ctx.save();
    ctx.globalCompositeOperation = "lighter";

    const pulse = getOmPulse();
    const polarity = Math.sin(performance.now() * 0.00008) * wake;
    const rot = performance.now() * 0.00015 * (0.6 + pulse) * (1 + polarity);

    const fireBoost = FIRINGS.length ? 0.5 : 0;
    const strokeBase = isLight ? 0 : 255;
    const alpha = 0.12 + wake * 0.18 + fireBoost * 0.1;

    ctx.strokeStyle = `rgba(${strokeBase},${strokeBase},${strokeBase},${alpha})`;
    ctx.lineWidth = 1.4;

    const wobble = Math.sin(performance.now() * 0.001) * 0.04 * wake;

    const up = [
      [0, -radius * (1 + wobble)],
      [-radius * 0.86, radius * 0.5],
      [radius * 0.86, radius * 0.5],
    ];

    const down = [
      [0, radius * (1 + wobble)],
      [-radius * 0.86, -radius * 0.5],
      [radius * 0.86, -radius * 0.5],
    ];

    function drawTetra(points, r) {
      ctx.save();
      ctx.rotate(r);
      ctx.beginPath();
      for (let i = 0; i < points.length; i++) {
        const [x1, y1] = points[i];
        const [x2, y2] = points[(i + 1) % points.length];
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
      }
      for (const [x, y] of points) {
        ctx.moveTo(0, 0);
        ctx.lineTo(x, y);
      }
      ctx.stroke();
      ctx.restore();
    }

    drawTetra(up, rot);
    drawTetra(down, -rot * 0.92);

    ctx.restore();
  }

  function drawNeuralCore(radius) {
    ctx.save();

    const pulse = getOmPulse();
    const alpha = 0.18 + pulse * 0.25 + wake * 0.25;
    const strokeBase = isLight ? 0 : 255;

    ctx.lineWidth = 0.6;
    ctx.beginPath();

    for (const [i, j] of LINKS) {
      const n1 = nodes[i];
      const n2 = nodes[j];

      const bias = (pulse - 0.5) * 0.0006;
      n1.a += prefersReduced ? 0.0004 : n1.s + bias;
      n2.a += prefersReduced ? 0.0004 : n2.s + bias;

      sessionPhase += 0.00002;

      const r1 = radius * (0.55 + audio[n1.bin] * 0.5);
      const r2 = radius * (0.55 + audio[n2.bin] * 0.5);

      const x1 = Math.cos(n1.a + sessionPhase) * r1;
      const y1 = Math.sin(n1.a + sessionPhase) * r1;
      const x2 = Math.cos(n2.a + sessionPhase) * r2;
      const y2 = Math.sin(n2.a + sessionPhase) * r2;

      ctx.strokeStyle = `rgba(${strokeBase},${strokeBase},${strokeBase},${alpha})`;
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
    }
    ctx.stroke();

    ctx.fillStyle = isLight ? "#000" : "#fff";
    for (const n of nodes) {
      const r = radius * (0.55 + audio[n.bin] * 0.6);
      ctx.beginPath();
      ctx.arc(
        Math.cos(n.a + sessionPhase) * r,
        Math.sin(n.a + sessionPhase) * r,
        1.4 + wake * 0.6,
        0,
        Math.PI * 2,
      );
      ctx.fill();
    }

    for (let i = FIRINGS.length - 1; i >= 0; i--) {
      const f = FIRINGS[i];
      f.t += prefersReduced ? 0.02 : 0.05;

      if (f.t >= 1) {
        const [a, b] = f.link;
        const angle = (nodes[a].a + nodes[b].a) * 0.5 + sessionPhase;
        RIPPLES.push({ a: angle, s: 0.6 + wake * 0.6, life: 1 });
        FIRINGS.splice(i, 1);
      }
    }

    maybeFire();
    ctx.restore();
  }

  /* ───────────────── MAIN DRAW ───────────────── */
  function draw() {
    const cx = cssW / 2;
    const cy = cssH / 2;

    ctx.clearRect(0, 0, cssW, cssH);
    ctx.save();
    ctx.translate(cx, cy);

    const neuralRadius = 54;
    const barBase = 60;

    drawCephalonCore(neuralRadius * 0.95);
    drawMerkaba(neuralRadius * 1.08);
    drawNeuralCore(neuralRadius);

    const step = (Math.PI * 2) / audio.length;
    ctx.fillStyle = isLight ? "rgba(0,0,0,0.7)" : "rgba(255,255,255,0.7)";

    for (let i = 0; i < audio.length; i++) {
      ctx.rotate(step);

      let rippleBoost = 0;
      const angle = i * step;
      for (const r of RIPPLES) {
        const d = Math.abs(
          Math.atan2(Math.sin(angle - r.a), Math.cos(angle - r.a)),
        );
        if (d < 0.3) rippleBoost += (1 - d / 0.3) * r.s * r.life;
      }

      const repel = Math.max(0, neuralRadius + 6 - barBase);
      ctx.fillRect(
        -1,
        barBase + repel,
        (audio[i] + rippleBoost) * 42 > 0 ? 2 : 0,
        (audio[i] + rippleBoost) * 42,
      );
    }

    for (let i = RIPPLES.length - 1; i >= 0; i--) {
      RIPPLES[i].life -= 0.05;
      if (RIPPLES[i].life <= 0) RIPPLES.splice(i, 1);
    }

    ctx.restore();
  }

  function frame() {
    updateAudio();
    draw();
    requestAnimationFrame(frame);
  }

  frame();
</script>
