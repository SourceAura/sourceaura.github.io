---
import type { CollectionEntry } from "astro:content";

interface Props {
  post: CollectionEntry<"petals">;
  type?: "text" | "audio" | "video" | "photo" | "project";

  width?: number;
  height?: number;

  sphereRad?: number;
  radiusSp?: number;
  projectionScale?: number;

  maxParticles?: number;
  particlesPerFrame?: number;

  particleRad?: number;

  turnSpeed?: number;

  materialStrength?: number;
  gammaDark?: number;

  lockRatio?: number;
  driftVelocity?: number;
  driftJitter?: number;
  gravity?: number;
  damping?: number;

  nearPlaneEpsilon?: number;
}

const {
  post,
  width = 720,
  height = 416,

  // â†“ 30% smaller than 150
  sphereRad = 105,
  radiusSp = 1,
  // slightly smaller projection to keep the orb visually compact
  projectionScale = 0.86,

  maxParticles = 3200,
  particlesPerFrame = 28,

  particleRad = 1.9,

  turnSpeed = (2 * Math.PI) / 1200,

  materialStrength = 1.1,
  gammaDark = 0.86,

  lockRatio = 0.62,
  driftVelocity = 0.012,
  driftJitter = 0.028,
  gravity = 0,
  damping = 0.985,

  nearPlaneEpsilon = 24,
} = Astro.props;

/* Extract first markdown image */
let imageSrc: string | null = null;
const match = post.body.match(/!\[.*?\]\((.*?)\)/);
if (match?.[1]) {
  const raw = match[1].trim();
  imageSrc =
    raw.startsWith("http") || raw.startsWith("/")
      ? raw
      : `/images/${raw.replace(/^\.?\//, "")}`;
}

const uid = `orb_${Math.random().toString(16).slice(2)}`;
const canvasId = `${uid}_canvas`;
---

<div
  class="ps-wrap"
  data-ps-root={uid}
  style={`max-width:${width}px;max-height:${Math.max(width, height)}px;`}
>
  <canvas id={canvasId}></canvas>
</div>

<script
  is:inline
  define:vars={{
    uid,
    canvasId,
    sphereRad,
    radiusSp,
    projectionScale,
    maxParticles,
    particlesPerFrame,
    particleRad,
    turnSpeed,
    imageSrc,
    materialStrength,
    gammaDark,
    lockRatio,
    driftVelocity,
    driftJitter,
    gravity,
    damping,
    nearPlaneEpsilon,
  }}
>
  (() => {
    window.__orbMounted ??= new Set();
    if (window.__orbMounted.has(uid)) return;
    window.__orbMounted.add(uid);

    const canvas = document.getElementById(canvasId);
    const ctx = canvas?.getContext("2d");
    if (!canvas || !ctx) return;

    const reduceMotion = matchMedia("(prefers-reduced-motion: reduce)").matches;

    // ---------- Theme cache ----------
    let cachedMode = "source-over";
    let isDark = false;
    let fallbackRGB = "0,0,0";

    function refreshRenderStyle() {
      const rootStyle = getComputedStyle(document.documentElement);
      const wrap = document.querySelector(`[data-ps-root="${uid}"]`);
      const wrapStyle = wrap ? getComputedStyle(wrap) : rootStyle;

      const c = wrapStyle.color;
      const m = c.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
      fallbackRGB = m ? `${m[1]},${m[2]},${m[3]}` : "0,0,0";

      cachedMode =
        rootStyle.getPropertyValue("--ps-composite-mode").trim() ||
        "source-over";
      isDark = document.documentElement.classList.contains("dark");
    }

    refreshRenderStyle();
    const moTheme = new MutationObserver(refreshRenderStyle);
    moTheme.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["class", "style"],
    });

    // ---------- Texture ----------
    let texReady = false;
    let texW = 0,
      texH = 0;
    let texData = null;

    function loadTexture(src) {
      if (!src) return;
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.decoding = "async";
      img.loading = "eager";
      img.src = src;

      img.onload = () => {
        const maxDim = 340;
        const scale = Math.min(
          1,
          maxDim / Math.max(img.naturalWidth, img.naturalHeight),
        );
        texW = Math.max(1, Math.floor(img.naturalWidth * scale));
        texH = Math.max(1, Math.floor(img.naturalHeight * scale));

        const tcan = document.createElement("canvas");
        tcan.width = texW;
        tcan.height = texH;
        const tctx = tcan.getContext("2d", { willReadFrequently: true });
        if (!tctx) return;

        tctx.drawImage(img, 0, 0, texW, texH);
        texData = tctx.getImageData(0, 0, texW, texH).data;
        texReady = true;
      };

      img.onerror = () => {
        texReady = false;
        texData = null;
      };
    }

    loadTexture(imageSrc);

    function sampleTexture(u, v) {
      if (!texReady || !texData) return null;

      u = u - Math.floor(u);
      v = v < 0 ? 0 : v > 1 ? 1 : v;

      const x = Math.floor(u * (texW - 1));
      const y = Math.floor(v * (texH - 1));
      const idx = (y * texW + x) * 4;

      let r = texData[idx];
      let g = texData[idx + 1];
      let b = texData[idx + 2];
      const a = texData[idx + 3] / 255;

      if (isDark && gammaDark !== 1) {
        const inv = 1 / 255;
        r = Math.round(255 * Math.pow(r * inv, gammaDark));
        g = Math.round(255 * Math.pow(g * inv, gammaDark));
        b = Math.round(255 * Math.pow(b * inv, gammaDark));
      }

      return { r, g, b, a };
    }

    // ---------- Square sizing (prevents oval distortion) ----------
    let S = 256;
    let dpr = 1;
    let W = 256,
      H = 256;

    function resizeToDisplaySquare() {
      const rect = canvas.getBoundingClientRect();
      const cssW = Math.max(1, rect.width);
      const cssH = Math.max(1, rect.height);

      S = Math.floor(Math.min(cssW, cssH));
      dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

      const px = Math.floor(S * dpr);
      if (canvas.width !== px || canvas.height !== px) {
        canvas.width = px;
        canvas.height = px;
      }

      W = S;
      H = S;
    }

    const ro = new ResizeObserver(resizeToDisplaySquare);
    ro.observe(canvas);
    resizeToDisplaySquare();

    // ---------- Projection ----------
    const fLen = 320;
    const zMax = fLen - 2;
    const sphereCenterZ = () => -3 - sphereRad;

    // ---------- Particle pool ----------
    const N = Math.max(1, maxParticles | 0);

    const x = new Float32Array(N);
    const y = new Float32Array(N);
    const z = new Float32Array(N);

    const vx = new Float32Array(N);
    const vy = new Float32Array(N);
    const vz = new Float32Array(N);

    const theta = new Float32Array(N);
    const phi = new Float32Array(N);

    const age = new Uint16Array(N);
    const stuck = new Uint16Array(N);
    const locked = new Uint8Array(N);
    const alive = new Uint8Array(N);

    let writeIndex = 0;

    function randn() {
      return Math.random() * 2 - 1;
    }

    function makeTangential(i, nx, ny, nz) {
      const dot = vx[i] * nx + vy[i] * ny + vz[i] * nz;
      vx[i] -= dot * nx;
      vy[i] -= dot * ny;
      vz[i] -= dot * nz;
    }

    function resetParticle(i) {
      const th = Math.random() * Math.PI * 2;
      const ph = Math.acos(Math.random() * 2 - 1);

      theta[i] = th;
      phi[i] = ph;

      const s = Math.sin(ph);
      const nx = s * Math.cos(th);
      const ny = s * Math.sin(th);
      const nz = Math.cos(ph);

      const scz = sphereCenterZ();

      x[i] = sphereRad * nx;
      y[i] = sphereRad * ny;
      z[i] = scz + sphereRad * nz;

      const isLocked = Math.random() < lockRatio;
      locked[i] = isLocked ? 1 : 0;

      vx[i] = isLocked ? 0 : driftVelocity * randn();
      vy[i] = isLocked ? 0 : driftVelocity * randn();
      vz[i] = isLocked ? 0 : driftVelocity * randn();
      if (!isLocked) makeTangential(i, nx, ny, nz);

      age[i] = 0;
      stuck[i] = (50 + Math.random() * 30) | 0;

      alive[i] = 1;
    }

    function spawnSome() {
      const n = particlesPerFrame | 0;
      for (let k = 0; k < n; k++) {
        const i = writeIndex;
        writeIndex = (writeIndex + 1) % N;
        resetParticle(i);
      }
    }

    // Prime pool faster for instant visibility
    for (let i = 0; i < Math.min(N, 1100); i++) resetParticle(i);

    // ---------- Render loop ----------
    let turnAngle = 0;
    let raf = 0;

    function beginFrame() {
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.imageSmoothingEnabled = false;

      // clear
      ctx.globalCompositeOperation = "source-over";
      ctx.clearRect(0, 0, W, H);

      // blend mode only (NO glow)
      ctx.globalCompositeOperation = cachedMode;
      ctx.shadowBlur = 0;
      ctx.shadowColor = "transparent";
    }

    function endFrame() {
      ctx.globalCompositeOperation = "source-over";
      ctx.shadowBlur = 0;
      ctx.shadowColor = "transparent";
    }

    function draw() {
      spawnSome();

      turnAngle = (turnAngle + turnSpeed) % (Math.PI * 2);
      const sinA = Math.sin(turnAngle);
      const cosA = Math.cos(turnAngle);

      beginFrame();

      const scz = sphereCenterZ();
      const inv2pi = 1 / (Math.PI * 2);

      const projCenterX = W / 2;
      const projCenterY = H / 2;

      for (let i = 0; i < N; i++) {
        if (!alive[i]) continue;

        age[i]++;

        if (!locked[i] && age[i] > stuck[i]) {
          const dx = x[i];
          const dy = y[i];
          const dz = z[i] - scz;

          const r = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;
          const nx = dx / r;
          const ny = dy / r;
          const nz = dz / r;

          vx[i] += driftJitter * randn();
          vy[i] += driftJitter * randn() + gravity;
          vz[i] += driftJitter * randn();

          makeTangential(i, nx, ny, nz);

          vx[i] *= damping;
          vy[i] *= damping;
          vz[i] *= damping;

          x[i] += vx[i];
          y[i] += vy[i];
          z[i] += vz[i];

          // re-project to exact sphere radius
          const dx2 = x[i];
          const dy2 = y[i];
          const dz2 = z[i] - scz;
          const r2 = Math.sqrt(dx2 * dx2 + dy2 * dy2 + dz2 * dz2) || 1;

          const s2 = sphereRad / r2;
          x[i] = dx2 * s2;
          y[i] = dy2 * s2;
          z[i] = scz + dz2 * s2;

          if (
            !Number.isFinite(x[i]) ||
            !Number.isFinite(y[i]) ||
            !Number.isFinite(z[i])
          ) {
            resetParticle(i);
            continue;
          }
        }

        const rotX = cosA * x[i] + sinA * (z[i] - scz);
        const rotZ = -sinA * x[i] + cosA * (z[i] - scz) + scz;

        const denom = fLen - rotZ;
        if (denom < nearPlaneEpsilon || rotZ > zMax) continue;

        const m = (radiusSp * fLen * projectionScale) / denom;
        if (!(m > 0 && m < 10)) continue;

        const px = rotX * m + projCenterX;
        const py = y[i] * m + projCenterY;
        if (px < -2 || px > W + 2 || py < -2 || py > H + 2) continue;

        let depth = 1 - rotZ / -750;
        depth = depth < 0 ? 0 : depth > 1 ? 1 : depth;

        const u = theta[i] * inv2pi + turnAngle * inv2pi;
        const v = phi[i] / Math.PI;

        const tex = sampleTexture(u, v);

        let rgb = fallbackRGB;
        let texA = 1;

        if (tex) {
          rgb = `${tex.r},${tex.g},${tex.b}`;
          texA = Math.max(0.5, tex.a);
        }

        const a = Math.min(1, Math.max(0.1, depth * texA * materialStrength));

        ctx.fillStyle = `rgba(${rgb}, ${a})`;
        ctx.beginPath();
        ctx.arc(px, py, m * particleRad, 0, Math.PI * 2);
        ctx.fill();
      }

      endFrame();
      raf = requestAnimationFrame(draw);
    }

    if (!reduceMotion) draw();

    window.addEventListener(
      "astro:before-swap",
      () => {
        cancelAnimationFrame(raf);
        moTheme.disconnect();
        ro.disconnect();
        window.__orbMounted.delete(uid);
      },
      { once: true },
    );
  })();
</script>

<style>
  .ps-wrap {
    width: 100%;
    height: 100%;
    display: grid;
    place-items: center;
    color: inherit;
  }

  canvas {
    width: 100%;
    height: 100%;
    aspect-ratio: 1 / 1;
    display: block;
    background: transparent;
  }

  :global(html.dark) {
    /* keep your blend mode if you like; glow is removed in JS */
    --ps-composite-mode: lighter;
    --ps-glow: off;
  }

  :global(html.light) {
    --ps-composite-mode: multiply;
    --ps-glow: off;
  }
</style>
