---
import type { CollectionEntry } from "astro:content";

interface Props {
  post: CollectionEntry<"petals">;
  type?: "text" | "audio" | "video" | "photo" | "project";

  width?: number;
  height?: number;

  sphereRad?: number;
  projectionScale?: number;
  radiusSp?: number;

  // Density
  particlesPerFrame?: number;
  maxParticles?: number;
  particleRad?: number;

  // Rotation speeds
  yawSpeed?: number;
  pitchSpeed?: number;
  rollSpeed?: number;

  // Dark glow tuning
  glowBlur?: number;
  glowStrength?: number;

  // Material strength
  materialStrength?: number;

  // Scanline shimmer
  shimmerStrength?: number;
  shimmerSpeed?: number;

  // Gamma correction (dark mode pop)
  gammaDark?: number;

  // Drift physics controls
  lockRatio?: number;
  driftVelocity?: number;
  driftJitter?: number;
  gravity?: number;
  maxDriftRadius?: number;

  // Spring + orbit controls
  springK?: number;
  damping?: number;
  orbitK?: number;
  targetRadiusMul?: number;

  // Field-line swirl
  swirlMix?: number;

  // Performance knobs
  glowEvery?: number;
  useSquares?: boolean;

  // NEW: Depth scaling controls
  depthScaleStrength?: number; // 0..1; bigger = front LEDs larger
  depthBrightStrength?: number; // 0..1; bigger = front LEDs brighter

  // NEW: Dithering + contrast controls
  ditherStrength?: number; // 0..1
  ditherContrast?: number; // >=1 increases contrast
}

const {
  post,
  width = 720,
  height = 416,

  sphereRad = 280,
  radiusSp = 1,
  projectionScale = 0.88,

  // Image visibility
  particlesPerFrame = 42,
  maxParticles = 2600,
  particleRad = 1.35,

  glowBlur = 6,
  glowStrength = 0.45,

  yawSpeed = (2 * Math.PI) / 1400,
  pitchSpeed = (2 * Math.PI) / 2200,
  rollSpeed = (2 * Math.PI) / 3000,

  materialStrength = 1,

  shimmerStrength = 0.08,
  shimmerSpeed = 1.6,

  gammaDark = 0.86,

  // Drift
  lockRatio = 0.88,
  driftVelocity = 0.0018,
  driftJitter = 0.06,
  gravity = 0,
  maxDriftRadius = 2.6,

  // Spring orbit
  springK = 0.0022,
  damping = 0.985,
  orbitK = 0.0014,
  targetRadiusMul = 1.02,

  // Field lines
  swirlMix = 0.18,

  // Perf
  glowEvery = 6,
  useSquares = true,

  // NEW depth scaling
  depthScaleStrength = 0.55,
  depthBrightStrength = 0.22,

  // NEW dithering
  ditherStrength = 0.55,
  ditherContrast = 1.25,
} = Astro.props;

/* Extract first markdown image */
let imageSrc: string | null = null;
const match = post.body.match(/!\[.*?\]\((.*?)\)/);
if (match?.[1]) {
  const raw = match[1].trim();
  imageSrc =
    raw.startsWith("http") || raw.startsWith("/")
      ? raw
      : `/images/${raw.replace(/^\.?\//, "")}`;
}

const uid = `orb_${Math.random().toString(16).slice(2)}`;
const canvasId = `${uid}_canvas`;
---

<div class="orb-led-wrap" data-orb-led-root={uid}>
  <canvas id={canvasId} width={width} height={height}></canvas>
</div>

<script
  is:inline
  define:vars={{
    uid,
    canvasId,
    sphereRad,
    radiusSp,
    projectionScale,
    particlesPerFrame,
    maxParticles,
    particleRad,
    glowBlur,
    glowStrength,
    yawSpeed,
    pitchSpeed,
    rollSpeed,
    imageSrc,
    materialStrength,
    shimmerStrength,
    shimmerSpeed,
    gammaDark,
    lockRatio,
    driftVelocity,
    driftJitter,
    gravity,
    maxDriftRadius,
    springK,
    damping,
    orbitK,
    targetRadiusMul,
    swirlMix,
    glowEvery,
    useSquares,
    depthScaleStrength,
    depthBrightStrength,
    ditherStrength,
    ditherContrast,
  }}
>
  (() => {
    window.__orbMounted ??= new Set();
    if (window.__orbMounted.has(uid)) return;
    window.__orbMounted.add(uid);

    const canvas = document.getElementById(canvasId);
    const ctx = canvas?.getContext("2d");
    if (!canvas || !ctx) return;

    const reduceMotion = matchMedia("(prefers-reduced-motion: reduce)").matches;

    const w = canvas.width;
    const h = canvas.height;

    const fLen = 320;
    const projCenterX = w / 2;
    const projCenterY = h / 2;
    const centerYOffset = -sphereRad * 0.15;
    const zMax = fLen - 2;

    const particleList = { first: null };
    const recycleBin = { first: null };
    let liveCount = 0;

    const sphereCenterZ = () => -3 - sphereRad;
    const targetR = sphereRad * targetRadiusMul;
    const maxR = sphereRad * maxDriftRadius;

    let rotYaw = 0,
      rotPitch = 0,
      rotRoll = 0;

    let lastTime = performance.now();
    let phase = 0;

    let cachedMode = "source-over";
    let cachedGlow = "off";
    let isDark = false;
    let fallbackRGB = "0,0,0";

    function refreshTheme() {
      const root = getComputedStyle(document.documentElement);
      cachedMode =
        root.getPropertyValue("--ps-composite-mode").trim() || "source-over";
      cachedGlow = root.getPropertyValue("--ps-glow").trim() || "off";
      isDark = document.documentElement.classList.contains("dark");

      const wrap = document.querySelector(`[data-orb-led-root="${uid}"]`);
      const c = getComputedStyle(wrap ?? document.documentElement).color;
      const m = c.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      fallbackRGB = m ? `${m[1]},${m[2]},${m[3]}` : "0,0,0";
    }

    refreshTheme();
    const moTheme = new MutationObserver(refreshTheme);
    moTheme.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["class", "style"],
    });

    function cross(ax, ay, az, bx, by, bz) {
      return {
        x: ay * bz - az * by,
        y: az * bx - ax * bz,
        z: ax * by - ay * bx,
      };
    }

    // ---- Ordered dithering (Bayer 4x4) ----
    // returns threshold in [0..1)
    const BAYER4 = [
      [0, 8, 2, 10],
      [12, 4, 14, 6],
      [3, 11, 1, 9],
      [15, 7, 13, 5],
    ];
    function bayerThreshold(x, y) {
      const v = BAYER4[y & 3][x & 3];
      return (v + 0.5) / 16;
    }
    function clamp01(v) {
      return v < 0 ? 0 : v > 1 ? 1 : v;
    }

    // ---- Texture sampling ----
    let texReady = false,
      texW = 0,
      texH = 0,
      texData = null;

    if (imageSrc) {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.decoding = "async";
      img.loading = "eager";
      img.src = imageSrc;
      img.onload = () => {
        // slightly sharper sampling for visibility
        const maxDim = 384;
        const scale = Math.min(
          1,
          maxDim / Math.max(img.naturalWidth, img.naturalHeight),
        );
        texW = Math.max(1, (img.naturalWidth * scale) | 0);
        texH = Math.max(1, (img.naturalHeight * scale) | 0);

        const c = document.createElement("canvas");
        c.width = texW;
        c.height = texH;
        const ictx = c.getContext("2d", { willReadFrequently: true });
        if (!ictx) return;

        ictx.drawImage(img, 0, 0, texW, texH);
        texData = ictx.getImageData(0, 0, texW, texH).data;
        texReady = true;
      };
    }

    function sample(u, v) {
      if (!texReady || !texData) return null;
      u -= Math.floor(u);
      v = v < 0 ? 0 : v > 1 ? 1 : v;
      const x = (u * (texW - 1)) | 0;
      const y = (v * (texH - 1)) | 0;
      const i = (y * texW + x) * 4;

      let r = texData[i];
      let g = texData[i + 1];
      let b = texData[i + 2];
      const a = texData[i + 3] / 255;

      // Gamma correction in dark mode
      if (isDark && gammaDark !== 1) {
        const inv = 1 / 255;
        r = (255 * Math.pow(r * inv, gammaDark)) | 0;
        g = (255 * Math.pow(g * inv, gammaDark)) | 0;
        b = (255 * Math.pow(b * inv, gammaDark)) | 0;
      }

      return { r, g, b, a };
    }

    // ---- Fibonacci spawn ----
    let spawnIndex = 0;
    const golden = Math.PI * (3 - Math.sqrt(5));

    function addParticle(theta, phi, x, y, z, vx, vy, vz, locked) {
      let p = recycleBin.first || {};
      if (recycleBin.first) {
        recycleBin.first = p.next;
        if (p.next) p.next.prev = null;
      }

      p.next = particleList.first;
      if (particleList.first) particleList.first.prev = p;
      particleList.first = p;
      p.prev = null;

      p.theta = theta;
      p.phi = phi;

      p.x = x;
      p.y = y;
      p.z = z;

      p.vx = vx;
      p.vy = vy;
      p.vz = vz;

      p.locked = !!locked;

      // simple life for non-locked drift particles
      p.age = 0;
      p.stuck = 45 + Math.random() * 25;
      p.life = 520 + Math.random() * 220;

      p.id = (Math.random() * 1e9) | 0;

      liveCount++;
      return p;
    }

    function recycle(p) {
      if (particleList.first === p) {
        particleList.first = p.next;
        if (p.next) p.next.prev = null;
      } else {
        if (p.prev) p.prev.next = p.next;
        if (p.next) p.next.prev = p.prev;
      }

      p.next = recycleBin.first;
      if (recycleBin.first) recycleBin.first.prev = p;
      recycleBin.first = p;
      p.prev = null;

      liveCount = Math.max(0, liveCount - 1);
    }

    function spawn() {
      if (liveCount >= maxParticles) return;

      const remaining = maxParticles - liveCount;
      const n = Math.min(particlesPerFrame, remaining);
      const scz = sphereCenterZ();

      for (let i = 0; i < n; i++) {
        const k = spawnIndex++;
        const t = (k + 0.5) / maxParticles;
        const yN = 1 - 2 * t;
        const rN = Math.sqrt(Math.max(0, 1 - yN * yN));
        const ang = golden * k;

        const nx = Math.cos(ang) * rN;
        const ny = yN;
        const nz = Math.sin(ang) * rN;

        const theta = Math.atan2(nz, nx);
        const phi = Math.acos(ny);

        const x0 = sphereRad * nx;
        const y0 = sphereRad * ny;
        const z0 = sphereRad * nz;

        const locked = Math.random() < lockRatio;

        addParticle(
          theta < 0 ? theta + Math.PI * 2 : theta,
          phi,
          x0,
          y0,
          scz + z0,
          locked ? 0 : driftVelocity * x0,
          locked ? 0 : driftVelocity * y0,
          locked ? 0 : driftVelocity * z0,
          locked,
        );
      }
    }

    function drawDot(x, y, size) {
      if (!useSquares) {
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
        return;
      }
      const s = Math.max(1, size | 0);
      ctx.fillRect(x - s * 0.5, y - s * 0.5, s, s);
    }

    function draw() {
      spawn();

      const now = performance.now();
      const dt = Math.min(0.05, (now - lastTime) / 1000);
      lastTime = now;
      phase += dt * shimmerSpeed;

      rotYaw += yawSpeed;
      rotPitch += pitchSpeed;
      rotRoll += rollSpeed;

      const cy = Math.cos(rotYaw),
        sy = Math.sin(rotYaw);
      const cx = Math.cos(rotPitch),
        sx = Math.sin(rotPitch);
      const cz = Math.cos(rotRoll),
        sz = Math.sin(rotRoll);

      // orbit axis rotates with the orb (rotate world-up by the same chain)
      let ax = 0,
        ay = 1,
        az = 0;

      // pitch
      let ay1 = cx * ay - sx * az;
      let az1 = sx * ay + cx * az;
      let ax1 = ax;

      // yaw
      let ax2 = cy * ax1 + sy * az1;
      let az2 = -sy * ax1 + cy * az1;
      let ay2 = ay1;

      // roll
      let ax3 = cz * ax2 - sz * ay2;
      let ay3 = sz * ax2 + cz * ay2;
      let az3 = az2;

      const orbitAxisX = ax3;
      const orbitAxisY = ay3;
      const orbitAxisZ = az3;

      const scz = sphereCenterZ();

      ctx.clearRect(0, 0, w, h);
      ctx.globalCompositeOperation = cachedMode;

      // ---------- PASS 1: base pass (NO glow) ----------
      ctx.shadowBlur = 0;
      ctx.shadowColor = "transparent";

      let p = particleList.first;
      while (p) {
        const next = p.next;

        // drift physics for non-locked
        if (!p.locked) {
          p.age++;

          if (p.age > p.stuck) {
            const dx = p.x;
            const dy = p.y;
            const dz = p.z - scz;

            const r = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;
            const nxr = dx / r;
            const nyr = dy / r;
            const nzr = dz / r;

            // radial spring to target radius
            const dr = targetR - r;
            const axSpring = springK * dr * nxr;
            const aySpring = springK * dr * nyr;
            const azSpring = springK * dr * nzr;

            // tangent = axis × radial
            const t = cross(orbitAxisX, orbitAxisY, orbitAxisZ, nxr, nyr, nzr);
            const tl = Math.sqrt(t.x * t.x + t.y * t.y + t.z * t.z) || 1;
            let tx = t.x / tl,
              ty = t.y / tl,
              tz = t.z / tl;

            // optional corkscrew: t2 = radial × tangent
            if (swirlMix > 0.001) {
              const t2 = cross(nxr, nyr, nzr, tx, ty, tz);
              const t2l =
                Math.sqrt(t2.x * t2.x + t2.y * t2.y + t2.z * t2.z) || 1;
              const sx2 = t2.x / t2l;
              const sy2 = t2.y / t2l;
              const sz2 = t2.z / t2l;

              const bx = tx * (1 - swirlMix) + sx2 * swirlMix;
              const by = ty * (1 - swirlMix) + sy2 * swirlMix;
              const bz = tz * (1 - swirlMix) + sz2 * swirlMix;

              const bl = Math.sqrt(bx * bx + by * by + bz * bz) || 1;
              tx = bx / bl;
              ty = by / bl;
              tz = bz / bl;
            }

            // apply forces + jitter
            p.vx +=
              axSpring + orbitK * tx + driftJitter * (Math.random() * 2 - 1);
            p.vy +=
              aySpring +
              orbitK * ty +
              gravity +
              driftJitter * (Math.random() * 2 - 1);
            p.vz +=
              azSpring + orbitK * tz + driftJitter * (Math.random() * 2 - 1);

            // damping
            p.vx *= damping;
            p.vy *= damping;
            p.vz *= damping;

            // integrate
            p.x += p.vx;
            p.y += p.vy;
            p.z += p.vz;

            // kill if too far
            const r2 = p.x * p.x + p.y * p.y + (p.z - scz) * (p.z - scz);
            if (r2 > maxR * maxR || p.age > p.life) {
              recycle(p);
              p = next;
              continue;
            }
          }
        }

        // --- rotate current position (pitch -> yaw -> roll) ---
        let x = p.x;
        let y = p.y;
        let z = p.z - scz;

        // pitch
        let y1p = cx * y - sx * z;
        let z1p = sx * y + cx * z;

        // yaw
        let x2p = cy * x + sy * z1p;
        let z2p = -sy * x + cy * z1p;

        // roll
        let x3p = cz * x2p - sz * y1p;
        let y3p = sz * x2p + cz * y1p;

        const rotX = x3p;
        const rotY = y3p;
        const rotZ = z2p + scz;

        if (rotZ > zMax) {
          p = next;
          continue;
        }

        // projection
        const m = (radiusSp * fLen * projectionScale) / (fLen - rotZ);
        const px = rotX * m + projCenterX;
        const py = rotY * m + projCenterY + centerYOffset;

        if (px < 0 || px > w || py < 0 || py > h) {
          p = next;
          continue;
        }

        // depth factor (near = 1, far = 0-ish)
        // rotZ is negative; nearer points have larger m and usually less-negative rotZ.
        let depth = 1 - rotZ / -750; // tuned constant; stable across your prior versions
        depth = clamp01(depth);

        // Depth-based pixel scaling (front LEDs bigger)
        const sizeBoost = 1 + depthScaleStrength * depth;
        const baseSize = m * particleRad * sizeBoost;

        // UV scroll by yaw (material rotates)
        const u = p.theta / (Math.PI * 2) + rotYaw / (Math.PI * 2);
        const v = p.phi / Math.PI;

        const tex = sample(u, v);

        let r = 0,
          g = 0,
          b = 0,
          a = 1;

        if (tex) {
          r = tex.r;
          g = tex.g;
          b = tex.b;
          a = tex.a;
        } else {
          // fallbackRGB is "r,g,b"
          const parts = fallbackRGB.split(",");
          r = +parts[0] || 0;
          g = +parts[1] || 0;
          b = +parts[2] || 0;
          a = 1;
        }

        // --- Contrast curve + ordered dithering (boost perceived detail) ---
        // luminance
        let lum = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;

        // contrast
        lum = clamp01((lum - 0.5) * ditherContrast + 0.5);

        // ordered dither threshold from screen position
        const thr = bayerThreshold(px | 0, py | 0);

        // dither mask: binary-ish but softened by ditherStrength
        // when lum < thr, we reduce alpha (not fully off) to avoid holes
        const mask = lum > thr ? 1 : 0;
        const ditherAlpha =
          1 - ditherStrength + ditherStrength * (0.28 + 0.72 * mask);

        // scanline shimmer (subtle)
        const scan = Math.sin(phase + v * Math.PI * 14);
        const shimmer = 1 + shimmerStrength * scan;

        // depth brightening (front LEDs slightly brighter)
        const brightBoost = 1 + depthBrightStrength * depth;

        // final alpha
        const finalA = clamp01(
          a * materialStrength * shimmer * ditherAlpha * brightBoost,
        );

        ctx.fillStyle = `rgba(${r},${g},${b},${finalA})`;
        drawDot(px, py, baseSize);

        p = next;
      }

      // ---------- PASS 2: glow highlights (dark mode only) ----------
      if (cachedGlow === "on") {
        ctx.shadowBlur = glowBlur;
        ctx.shadowColor = `rgba(255,255,255,0.55)`;

        let q = particleList.first;
        while (q) {
          if (q.id % glowEvery === 0) {
            const scz2 = scz;

            let x = q.x;
            let y = q.y;
            let z = q.z - scz2;

            let y1p = cx * y - sx * z;
            let z1p = sx * y + cx * z;

            let x2p = cy * x + sy * z1p;
            let z2p = -sy * x + cy * z1p;

            let x3p = cz * x2p - sz * y1p;
            let y3p = sz * x2p + cz * y1p;

            const rotZ = z2p + scz2;
            if (rotZ <= zMax) {
              const m = (radiusSp * fLen * projectionScale) / (fLen - rotZ);
              const px = x3p * m + projCenterX;
              const py = y3p * m + projCenterY + centerYOffset;

              if (px >= 0 && px <= w && py >= 0 && py <= h) {
                let depth = 1 - rotZ / -750;
                depth = clamp01(depth);

                const a = clamp01(depth * glowStrength);
                ctx.fillStyle = `rgba(255,255,255,${a})`;

                const sizeBoost = 1 + depthScaleStrength * depth;
                drawDot(px, py, m * particleRad * sizeBoost);
              }
            }
          }
          q = q.next;
        }

        ctx.shadowBlur = 0;
        ctx.shadowColor = "transparent";
      }

      ctx.globalCompositeOperation = "source-over";
      requestAnimationFrame(draw);
    }

    if (!reduceMotion) draw();

    window.addEventListener(
      "astro:before-swap",
      () => {
        moTheme.disconnect();
        window.__orbMounted.delete(uid);
      },
      { once: true },
    );
  })();
</script>

<style>
  .orb-led-wrap {
    display: flex;
    justify-content: center;
    align-items: center;
    color: inherit;
  }

  canvas {
    display: block;
    max-width: 100%;
    height: auto;
    background: transparent;
  }

  :global(html.dark) {
    --ps-composite-mode: lighter;
    --ps-glow: on;
  }

  :global(html.light) {
    --ps-composite-mode: multiply;
    --ps-glow: off;
  }
</style>
