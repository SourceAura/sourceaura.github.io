---
import type { CollectionEntry } from "astro:content";

interface Props {
  post: CollectionEntry<"petals">;
  type?: "text" | "audio" | "video" | "photo" | "project";

  width?: number;
  height?: number;

  sphereRad?: number;
  projectionScale?: number;
  radiusSp?: number;

  // Density
  particlesPerFrame?: number;
  maxParticles?: number;
  particleRad?: number;

  // Rotation speeds
  yawSpeed?: number;
  pitchSpeed?: number;
  rollSpeed?: number;

  // Dark glow tuning
  glowBlur?: number;
  glowStrength?: number;

  // Material strength
  materialStrength?: number;

  // Scanline shimmer
  shimmerStrength?: number;
  shimmerSpeed?: number;

  // Gamma correction (dark mode pop)
  gammaDark?: number;

  // Drift physics controls
  lockRatio?: number; // 0..1 (how many stay glued to sphere)
  driftVelocity?: number; // initial outward velocity scale
  driftJitter?: number; // random accel amount
  gravity?: number; // y accel
  maxDriftRadius?: number; // multiplier of sphereRad

  // Spring + orbit controls
  springK?: number; // radial spring strength
  damping?: number; // velocity damping per frame (0..1)
  orbitK?: number; // tangential swirl strength
  targetRadiusMul?: number; // target radius multiplier (near surface)

  // NEW: secondary swirl for "field line" vibe (0..1)
  swirlMix?: number;
}

const {
  post,
  width = 720,
  height = 416,

  sphereRad = 210,
  radiusSp = 1,
  projectionScale = 0.88,

  // Density for readability
  particlesPerFrame = 77,
  maxParticles = 2000,
  particleRad = 1.65,

  glowBlur = 7,
  glowStrength = 0.45,

  yawSpeed = (2 * Math.PI) / 1400,
  pitchSpeed = (2 * Math.PI) / 2200,
  rollSpeed = (2 * Math.PI) / 3000,

  materialStrength = 1,

  shimmerStrength = 0.08,
  shimmerSpeed = 1.6,

  gammaDark = 0.86,

  // Drift
  lockRatio = 0.72,
  driftVelocity = 0.0018,
  driftJitter = 0.08,
  gravity = 0,
  maxDriftRadius = 2.6,

  // Spring orbit
  springK = 0.0022,
  damping = 0.985,
  orbitK = 0.0014,
  targetRadiusMul = 1.02,

  // Secondary swirl mix (field-line feel)
  swirlMix = 0.35,
} = Astro.props;

/* Extract first markdown image */
let imageSrc: string | null = null;

const match = post.body.match(/!\[.*?\]\((.*?)\)/);
if (match?.[1]) {
  const raw = match[1].trim();
  imageSrc =
    raw.startsWith("http") || raw.startsWith("/")
      ? raw
      : `/images/${raw.replace(/^\.?\//, "")}`;
}

const uid = `led_${Math.random().toString(16).slice(2)}`;
const canvasId = `${uid}_canvas`;
---

<div class="orb-led-wrap" data-orb-led-root={uid}>
  <canvas id={canvasId} width={width} height={height}></canvas>
</div>

<script
  is:inline
  define:vars={{
    uid,
    canvasId,
    sphereRad,
    radiusSp,
    projectionScale,
    particlesPerFrame,
    maxParticles,
    particleRad,
    glowBlur,
    glowStrength,
    yawSpeed,
    pitchSpeed,
    rollSpeed,
    imageSrc,
    materialStrength,
    shimmerStrength,
    shimmerSpeed,
    gammaDark,
    lockRatio,
    driftVelocity,
    driftJitter,
    gravity,
    maxDriftRadius,
    springK,
    damping,
    orbitK,
    targetRadiusMul,
    swirlMix,
  }}
>
  (() => {
    window.__orbLedMounted ??= new Set();
    if (window.__orbLedMounted.has(uid)) return;
    window.__orbLedMounted.add(uid);

    const canvas = document.getElementById(canvasId);
    const ctx = canvas?.getContext("2d");
    if (!canvas || !ctx) return;

    const reduceMotion = matchMedia("(prefers-reduced-motion: reduce)").matches;

    const displayWidth = canvas.width;
    const displayHeight = canvas.height;

    const fLen = 320;
    const projCenterX = displayWidth / 2;
    const projCenterY = displayHeight / 2;

    const centerYOffset = -sphereRad * 0.15;
    const zMax = fLen - 2;

    const particleAlpha = 1;
    const zeroAlphaDepth = -750;

    // Rotation angles
    let rotYaw = 0;
    let rotPitch = 0;
    let rotRoll = 0;

    // time for shimmer
    let lastTime = performance.now();
    let phase = 0;

    // Lists
    const particleList = { first: null };
    const recycleBin = { first: null };
    let liveCount = 0;

    const sphereCenterY = 0;
    const sphereCenterZ = () => -3 - sphereRad;

    const maxR = sphereRad * maxDriftRadius;
    const targetR = sphereRad * targetRadiusMul;

    let raf = 0;

    // Cached theme/composite + dark/light detection
    let cachedMode = "source-over";
    let cachedGlow = "off";
    let isDark = false;

    // Fallback if no image
    let fallbackRGB = "0,0,0";

    function refreshRenderStyle() {
      const rootStyle = getComputedStyle(document.documentElement);
      const wrap = document.querySelector(`[data-orb-led-root="${uid}"]`);
      const wrapStyle = wrap ? getComputedStyle(wrap) : rootStyle;

      const c = wrapStyle.color;
      const m = c.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
      fallbackRGB = m ? `${m[1]},${m[2]},${m[3]}` : "0,0,0";

      cachedMode =
        rootStyle.getPropertyValue("--ps-composite-mode").trim() ||
        "source-over";
      cachedGlow = rootStyle.getPropertyValue("--ps-glow").trim() || "off";
      isDark = document.documentElement.classList.contains("dark");
    }

    refreshRenderStyle();

    const moTheme = new MutationObserver(refreshRenderStyle);
    moTheme.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["class"],
    });

    const wrapEl = document.querySelector(`[data-orb-led-root="${uid}"]`);
    const moWrap = new MutationObserver(refreshRenderStyle);
    if (wrapEl) {
      moWrap.observe(wrapEl, {
        attributes: true,
        attributeFilter: ["style", "class"],
      });
    }

    // Vector helpers
    function cross(ax, ay, az, bx, by, bz) {
      return {
        x: ay * bz - az * by,
        y: az * bx - ax * bz,
        z: ax * by - ay * bx,
      };
    }

    // ---- Material image sampling (offscreen canvas) ----
    let texReady = false;
    let texW = 0;
    let texH = 0;
    let texData = null;

    function loadTexture(src) {
      if (!src) return;

      const img = new Image();
      img.crossOrigin = "anonymous";
      img.decoding = "async";
      img.loading = "eager";
      img.src = src;

      img.onload = () => {
        const maxDim = 320;
        const scale = Math.min(
          1,
          maxDim / Math.max(img.naturalWidth, img.naturalHeight),
        );
        texW = Math.max(1, Math.floor(img.naturalWidth * scale));
        texH = Math.max(1, Math.floor(img.naturalHeight * scale));

        const texCanvas = document.createElement("canvas");
        texCanvas.width = texW;
        texCanvas.height = texH;
        const texCtx = texCanvas.getContext("2d", { willReadFrequently: true });
        if (!texCtx) return;

        texCtx.drawImage(img, 0, 0, texW, texH);
        const imgData = texCtx.getImageData(0, 0, texW, texH);
        texData = imgData.data;
        texReady = true;
      };

      img.onerror = () => {
        texReady = false;
      };
    }

    loadTexture(imageSrc);

    function sampleTexture(u, v) {
      if (!texReady || !texData) return null;

      u = u - Math.floor(u);
      v = Math.max(0, Math.min(1, v));

      const x = Math.floor(u * (texW - 1));
      const y = Math.floor(v * (texH - 1));
      const idx = (y * texW + x) * 4;

      let r = texData[idx];
      let g = texData[idx + 1];
      let b = texData[idx + 2];
      const a = texData[idx + 3] / 255;

      // Gamma correction in dark mode
      if (isDark && gammaDark !== 1) {
        const inv = 1 / 255;
        r = Math.round(255 * Math.pow(r * inv, gammaDark));
        g = Math.round(255 * Math.pow(g * inv, gammaDark));
        b = Math.round(255 * Math.pow(b * inv, gammaDark));
      }

      return { r, g, b, a };
    }

    // ---- Particles: each has material coords (theta/phi) + drift position ----
    function addParticle(theta, phi, x, y, z, vx, vy, vz, locked) {
      let p = recycleBin.first || {};
      if (recycleBin.first) {
        recycleBin.first = p.next;
        if (p.next) p.next.prev = null;
      }

      p.next = particleList.first;
      if (particleList.first) particleList.first.prev = p;
      particleList.first = p;
      p.prev = null;

      p.theta = theta;
      p.phi = phi;

      p.x = x;
      p.y = y;
      p.z = z;

      p.velX = vx;
      p.velY = vy;
      p.velZ = vz;

      p.locked = !!locked;

      p.age = 0;
      p.alpha = 0;

      p.attack = 40;
      p.hold = 140;
      p.decay = 140;
      p.initValue = 0;
      p.holdValue = particleAlpha;
      p.lastValue = 0;

      p.stuckTime = 50 + Math.random() * 30;

      liveCount++;
      return p;
    }

    function recycle(p) {
      if (particleList.first === p) {
        particleList.first = p.next;
        if (p.next) p.next.prev = null;
      } else {
        if (p.prev) p.prev.next = p.next;
        if (p.next) p.next.prev = p.prev;
      }

      p.next = recycleBin.first;
      if (recycleBin.first) recycleBin.first.prev = p;
      recycleBin.first = p;
      p.prev = null;

      liveCount = Math.max(0, liveCount - 1);
    }

    function spawn() {
      if (liveCount >= maxParticles) return;

      const remaining = maxParticles - liveCount;
      const n = Math.min(particlesPerFrame, remaining);

      const scz = sphereCenterZ();

      for (let i = 0; i < n; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(Math.random() * 2 - 1);

        // initial surface vector
        const x0 = sphereRad * Math.sin(phi) * Math.cos(theta);
        const y0 = sphereRad * Math.sin(phi) * Math.sin(theta);
        const z0 = sphereRad * Math.cos(phi);

        const locked = Math.random() < lockRatio;

        const x = x0;
        const y = y0;
        const z = scz + z0;

        // outward initial push
        const vx = locked ? 0 : driftVelocity * x0;
        const vy = locked ? 0 : driftVelocity * y0;
        const vz = locked ? 0 : driftVelocity * z0;

        addParticle(theta, phi, x, y, z, vx, vy, vz, locked);
      }
    }

    function lighting(nx, ny, nz) {
      let lit = nx * -0.35 + ny * -0.25 + nz * 0.9;
      lit = Math.max(0, lit);
      return Math.pow(lit, 1.25);
    }

    function draw() {
      spawn();

      const now = performance.now();
      const dt = Math.min(0.05, (now - lastTime) / 1000);
      lastTime = now;

      phase += dt * shimmerSpeed;

      rotYaw = (rotYaw + yawSpeed) % (Math.PI * 2);
      rotPitch = (rotPitch + pitchSpeed) % (Math.PI * 2);
      rotRoll = (rotRoll + rollSpeed) % (Math.PI * 2);

      const cy = Math.cos(rotYaw),
        sy = Math.sin(rotYaw);
      const cx = Math.cos(rotPitch),
        sx = Math.sin(rotPitch);
      const cz = Math.cos(rotRoll),
        sz = Math.sin(rotRoll);

      // NEW: orbit axis rotates with the orb
      // Start with (0,1,0) and rotate it with the same chain (pitch -> yaw -> roll)
      let ax = 0,
        ay = 1,
        az = 0;

      // pitch
      let ay1 = cx * ay - sx * az;
      let az1 = sx * ay + cx * az;
      let ax1 = ax;

      // yaw
      let ax2 = cy * ax1 + sy * az1;
      let az2 = -sy * ax1 + cy * az1;
      let ay2 = ay1;

      // roll
      let ax3 = cz * ax2 - sz * ay2;
      let ay3 = sz * ax2 + cz * ay2;
      let az3 = az2;

      const orbitAxisX = ax3;
      const orbitAxisY = ay3;
      const orbitAxisZ = az3;

      ctx.clearRect(0, 0, displayWidth, displayHeight);
      ctx.globalCompositeOperation = cachedMode;

      if (cachedGlow === "on") {
        ctx.shadowBlur = glowBlur;
        ctx.shadowColor = `rgba(255,255,255,0.55)`;
      } else {
        ctx.shadowBlur = 0;
        ctx.shadowColor = "transparent";
      }

      const scz = sphereCenterZ();

      let p = particleList.first;
      while (p) {
        const next = p.next;
        p.age++;

        // Drift physics with inward spring + orbit (non-locked only)
        if (!p.locked && p.age > p.stuckTime) {
          // local radial vector from sphere center
          const dx = p.x;
          const dy = p.y;
          const dz = p.z - scz;

          const r = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;

          const nxr = dx / r;
          const nyr = dy / r;
          const nzr = dz / r;

          // radial spring back to target radius
          const dr = targetR - r;
          const axSpring = springK * dr * nxr;
          const aySpring = springK * dr * nyr;
          const azSpring = springK * dr * nzr;

          // NEW: tangential swirl around the orb's rotating axis
          // tangent = axis × radial
          const t = cross(orbitAxisX, orbitAxisY, orbitAxisZ, nxr, nyr, nzr);
          const tl = Math.sqrt(t.x * t.x + t.y * t.y + t.z * t.z) || 1;
          let tx = t.x / tl;
          let ty = t.y / tl;
          let tz = t.z / tl;

          // Optional: secondary swirl (field-line corkscrew)
          // t2 = radial × tangent
          if (swirlMix > 0) {
            const t2 = cross(nxr, nyr, nzr, tx, ty, tz);
            const t2l = Math.sqrt(t2.x * t2.x + t2.y * t2.y + t2.z * t2.z) || 1;
            const sx2 = t2.x / t2l;
            const sy2 = t2.y / t2l;
            const sz2 = t2.z / t2l;

            const bx = tx * (1 - swirlMix) + sx2 * swirlMix;
            const by = ty * (1 - swirlMix) + sy2 * swirlMix;
            const bz = tz * (1 - swirlMix) + sz2 * swirlMix;

            const bl = Math.sqrt(bx * bx + by * by + bz * bz) || 1;
            tx = bx / bl;
            ty = by / bl;
            tz = bz / bl;
          }

          // add forces + jitter
          p.velX +=
            axSpring + orbitK * tx + driftJitter * (Math.random() * 2 - 1);
          p.velY +=
            aySpring +
            orbitK * ty +
            gravity +
            driftJitter * (Math.random() * 2 - 1);
          p.velZ +=
            azSpring + orbitK * tz + driftJitter * (Math.random() * 2 - 1);

          // damping for stability
          p.velX *= damping;
          p.velY *= damping;
          p.velZ *= damping;

          // integrate
          p.x += p.velX;
          p.y += p.velY;
          p.z += p.velZ;

          // recycle if too far
          const r2 = p.x * p.x + p.y * p.y + (p.z - scz) * (p.z - scz);
          if (r2 > maxR * maxR) {
            recycle(p);
            p = next;
            continue;
          }
        }

        // --- TRUE 3D rotation of current position ---
        let x = p.x;
        let y = p.y;
        let z = p.z - scz;

        // pitch
        let y1p = cx * y - sx * z;
        let z1p = sx * y + cx * z;

        // yaw
        let x2p = cy * x + sy * z1p;
        let z2p = -sy * x + cy * z1p;

        // roll
        let x3p = cz * x2p - sz * y1p;
        let y3p = sz * x2p + cz * y1p;

        const rotX = x3p;
        const rotY = y3p;
        const rotZ = z2p + scz;

        const m = (radiusSp * fLen * projectionScale) / (fLen - rotZ);
        const px = rotX * m + projCenterX;
        const py = rotY * m + projCenterY + centerYOffset;

        if (
          px < 0 ||
          px > displayWidth ||
          py < 0 ||
          py > displayHeight ||
          rotZ > zMax
        ) {
          if (!p.locked) recycle(p);
          p = next;
          continue;
        }

        // Envelope alpha
        if (p.age < p.attack + p.hold + p.decay) {
          if (p.age < p.attack) p.alpha = (p.holdValue / p.attack) * p.age;
          else if (p.age < p.attack + p.hold) p.alpha = p.holdValue;
          else {
            p.alpha =
              ((p.lastValue - p.holdValue) / p.decay) *
                (p.age - p.attack - p.hold) +
              p.holdValue;
          }
        } else {
          if (p.locked) {
            p.age = 0;
            p.alpha = 0;
          } else {
            recycle(p);
            p = next;
            continue;
          }
        }

        // Depth
        let depth = 1 - rotZ / zeroAlphaDepth;
        depth = Math.max(0, Math.min(1, depth));
        const depthAlpha = Math.pow(depth, 1.25);

        // Lighting normal
        let nx, ny, nz;
        if (p.locked) {
          const sx0 = Math.sin(p.phi);
          nx = sx0 * Math.cos(p.theta);
          ny = sx0 * Math.sin(p.theta);
          nz = Math.cos(p.phi);

          // rotate normal with same rotation chain
          let ny1n = cx * ny - sx * nz;
          let nz1n = sx * ny + cx * nz;

          let nx2n = cy * nx + sy * nz1n;
          let nz2n = -sy * nx + cy * nz1n;

          let nx3n = cz * nx2n - sz * ny1n;
          let ny3n = sz * nx2n + cz * ny1n;

          nx = nx3n;
          ny = ny3n;
          nz = nz2n;
        } else {
          nx = rotX / sphereRad;
          ny = rotY / sphereRad;
          nz = z2p / sphereRad;
        }

        const lit = lighting(nx, ny, nz);
        const lightingBoost = 0.35 + 0.85 * lit;

        // UV anchored to particle material coords, scrolled by yaw
        const u = p.theta / (Math.PI * 2) + rotYaw / (Math.PI * 2);
        const v = p.phi / Math.PI;

        const tex = sampleTexture(u, v);

        let rgb = fallbackRGB;
        let texAlpha = 1;

        if (tex) {
          rgb = `${tex.r},${tex.g},${tex.b}`;
          texAlpha = tex.a;
        }

        // Scanline shimmer
        const scan = Math.sin(phase + v * Math.PI * 14);
        const shimmer = 1 + shimmerStrength * scan;

        const alphaBoost = cachedGlow === "on" ? glowStrength : 1;

        const baseA =
          texAlpha *
          p.alpha *
          depthAlpha *
          lightingBoost *
          alphaBoost *
          materialStrength;

        const ledAlpha = Math.max(0, Math.min(1, baseA * shimmer));

        ctx.fillStyle = `rgba(${rgb}, ${ledAlpha})`;

        const nearBoost = 0.78 + depth * 0.52;

        ctx.beginPath();
        ctx.arc(px, py, m * particleRad * nearBoost, 0, Math.PI * 2);
        ctx.fill();

        p = next;
      }

      ctx.globalCompositeOperation = "source-over";
      raf = requestAnimationFrame(draw);
    }

    if (!reduceMotion) draw();

    window.addEventListener(
      "astro:before-swap",
      () => {
        cancelAnimationFrame(raf);
        moTheme.disconnect();
        moWrap.disconnect();
        window.__orbLedMounted.delete(uid);
      },
      { once: true },
    );
  })();
</script>

<style>
  .orb-led-wrap {
    display: flex;
    justify-content: center;
    align-items: center;
    color: inherit;
  }

  canvas {
    display: block;
    max-width: 100%;
    height: auto;
    background: transparent;
  }

  :global(html.dark) {
    --ps-composite-mode: lighter;
    --ps-glow: on;
  }

  :global(html.light) {
    --ps-composite-mode: multiply;
    --ps-glow: off;
  }
</style>
