---
import type { CollectionEntry } from "astro:content";

interface Props {
  post: CollectionEntry<"petals">;
  type?: "text" | "audio" | "video" | "photo" | "project";

  width?: number;
  height?: number;

  sphereRad?: number;
  projectionScale?: number;
  radiusSp?: number;

  // Density
  particlesPerFrame?: number;
  maxParticles?: number;
  particleRad?: number;

  // Rotation speeds
  yawSpeed?: number;
  pitchSpeed?: number;
  rollSpeed?: number;

  // Dark glow tuning
  glowBlur?: number;
  glowStrength?: number;

  // Material strength
  materialStrength?: number;

  // Scanline shimmer
  shimmerStrength?: number;
  shimmerSpeed?: number;

  // Gamma correction (dark mode pop)
  gammaDark?: number;

  // Drift physics controls
  lockRatio?: number;
  driftVelocity?: number;
  driftJitter?: number;
  gravity?: number;
  maxDriftRadius?: number;

  // Spring + orbit controls
  springK?: number;
  damping?: number;
  orbitK?: number;
  targetRadiusMul?: number;

  // Secondary swirl (field lines)
  swirlMix?: number; // 0..1

  // NEW perf knobs
  glowEvery?: number; // glow 1 in N particles
  useSquares?: boolean; // squares are faster and more LED-like
}

const {
  post,
  width = 720,
  height = 416,

  sphereRad = 210,
  radiusSp = 1,
  projectionScale = 0.88,

  // PERF: slower ramp, slightly smaller pool
  particlesPerFrame = 28,
  maxParticles = 1600,
  particleRad = 1.65,

  glowBlur = 7,
  glowStrength = 0.45,

  yawSpeed = (2 * Math.PI) / 1400,
  pitchSpeed = (2 * Math.PI) / 2200,
  rollSpeed = (2 * Math.PI) / 3000,

  materialStrength = 1,

  shimmerStrength = 0.08,
  shimmerSpeed = 1.6,

  gammaDark = 0.86,

  lockRatio = 0.72,
  driftVelocity = 0.0018,
  driftJitter = 0.08,
  gravity = 0,
  maxDriftRadius = 2.6,

  springK = 0.0022,
  damping = 0.985,
  orbitK = 0.0014,
  targetRadiusMul = 1.02,

  // PERF: keep subtle, optional
  swirlMix = 0.18,

  // NEW perf knobs
  glowEvery = 4,
  useSquares = true,
} = Astro.props;

/* Extract first markdown image */
let imageSrc: string | null = null;

const match = post.body.match(/!\[.*?\]\((.*?)\)/);
if (match?.[1]) {
  const raw = match[1].trim();
  imageSrc =
    raw.startsWith("http") || raw.startsWith("/")
      ? raw
      : `/images/${raw.replace(/^\.?\//, "")}`;
}

const uid = `led_${Math.random().toString(16).slice(2)}`;
const canvasId = `${uid}_canvas`;
---

<div class="orb-led-wrap" data-orb-led-root={uid}>
  <canvas id={canvasId} width={width} height={height}></canvas>
</div>

<script
  is:inline
  define:vars={{
    uid,
    canvasId,
    sphereRad,
    radiusSp,
    projectionScale,
    particlesPerFrame,
    maxParticles,
    particleRad,
    glowBlur,
    glowStrength,
    yawSpeed,
    pitchSpeed,
    rollSpeed,
    imageSrc,
    materialStrength,
    shimmerStrength,
    shimmerSpeed,
    gammaDark,
    lockRatio,
    driftVelocity,
    driftJitter,
    gravity,
    maxDriftRadius,
    springK,
    damping,
    orbitK,
    targetRadiusMul,
    swirlMix,
    glowEvery,
    useSquares,
  }}
>
  (() => {
    window.__orbLedMounted ??= new Set();
    if (window.__orbLedMounted.has(uid)) return;
    window.__orbLedMounted.add(uid);

    const canvas = document.getElementById(canvasId);
    const ctx = canvas?.getContext("2d");
    if (!canvas || !ctx) return;

    const reduceMotion = matchMedia("(prefers-reduced-motion: reduce)").matches;

    const displayWidth = canvas.width;
    const displayHeight = canvas.height;

    const fLen = 320;
    const projCenterX = displayWidth / 2;
    const projCenterY = displayHeight / 2;

    const centerYOffset = -sphereRad * 0.15;
    const zMax = fLen - 2;

    const particleAlpha = 1;
    const zeroAlphaDepth = -750;

    let rotYaw = 0;
    let rotPitch = 0;
    let rotRoll = 0;

    let lastTime = performance.now();
    let phase = 0;

    const particleList = { first: null };
    const recycleBin = { first: null };
    let liveCount = 0;

    const sphereCenterZ = () => -3 - sphereRad;

    const maxR = sphereRad * maxDriftRadius;
    const targetR = sphereRad * targetRadiusMul;

    let raf = 0;

    let cachedMode = "source-over";
    let cachedGlow = "off";
    let isDark = false;

    let fallbackRGB = "0,0,0";

    function refreshRenderStyle() {
      const rootStyle = getComputedStyle(document.documentElement);
      const wrap = document.querySelector(`[data-orb-led-root="${uid}"]`);
      const wrapStyle = wrap ? getComputedStyle(wrap) : rootStyle;

      const c = wrapStyle.color;
      const m = c.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
      fallbackRGB = m ? `${m[1]},${m[2]},${m[3]}` : "0,0,0";

      cachedMode =
        rootStyle.getPropertyValue("--ps-composite-mode").trim() ||
        "source-over";
      cachedGlow = rootStyle.getPropertyValue("--ps-glow").trim() || "off";
      isDark = document.documentElement.classList.contains("dark");
    }

    refreshRenderStyle();

    const moTheme = new MutationObserver(refreshRenderStyle);
    moTheme.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["class"],
    });

    const wrapEl = document.querySelector(`[data-orb-led-root="${uid}"]`);
    const moWrap = new MutationObserver(refreshRenderStyle);
    if (wrapEl) {
      moWrap.observe(wrapEl, {
        attributes: true,
        attributeFilter: ["style", "class"],
      });
    }

    function cross(ax, ay, az, bx, by, bz) {
      return {
        x: ay * bz - az * by,
        y: az * bx - ax * bz,
        z: ax * by - ay * bx,
      };
    }

    // --- texture sampling (offscreen) ---
    let texReady = false;
    let texW = 0;
    let texH = 0;
    let texData = null;

    function loadTexture(src) {
      if (!src) return;

      const img = new Image();
      img.crossOrigin = "anonymous";
      img.decoding = "async";
      img.loading = "eager";
      img.src = src;

      img.onload = () => {
        const maxDim = 320;
        const scale = Math.min(
          1,
          maxDim / Math.max(img.naturalWidth, img.naturalHeight),
        );
        texW = Math.max(1, Math.floor(img.naturalWidth * scale));
        texH = Math.max(1, Math.floor(img.naturalHeight * scale));

        const texCanvas = document.createElement("canvas");
        texCanvas.width = texW;
        texCanvas.height = texH;
        const texCtx = texCanvas.getContext("2d", { willReadFrequently: true });
        if (!texCtx) return;

        texCtx.drawImage(img, 0, 0, texW, texH);
        const imgData = texCtx.getImageData(0, 0, texW, texH);
        texData = imgData.data;
        texReady = true;
      };

      img.onerror = () => {
        texReady = false;
      };
    }

    loadTexture(imageSrc);

    function sampleTexture(u, v) {
      if (!texReady || !texData) return null;

      u = u - Math.floor(u);
      v = Math.max(0, Math.min(1, v));

      const x = (u * (texW - 1)) | 0;
      const y = (v * (texH - 1)) | 0;
      const idx = (y * texW + x) * 4;

      let r = texData[idx];
      let g = texData[idx + 1];
      let b = texData[idx + 2];
      const a = texData[idx + 3] / 255;

      if (isDark && gammaDark !== 1) {
        const inv = 1 / 255;
        r = (255 * Math.pow(r * inv, gammaDark)) | 0;
        g = (255 * Math.pow(g * inv, gammaDark)) | 0;
        b = (255 * Math.pow(b * inv, gammaDark)) | 0;
      }

      return { r, g, b, a };
    }

    // --- particles ---
    function addParticle(theta, phi, x, y, z, vx, vy, vz, locked) {
      let p = recycleBin.first || {};
      if (recycleBin.first) {
        recycleBin.first = p.next;
        if (p.next) p.next.prev = null;
      }

      p.next = particleList.first;
      if (particleList.first) particleList.first.prev = p;
      particleList.first = p;
      p.prev = null;

      p.theta = theta;
      p.phi = phi;

      p.x = x;
      p.y = y;
      p.z = z;

      p.velX = vx;
      p.velY = vy;
      p.velZ = vz;

      p.locked = !!locked;

      p.age = 0;
      p.alpha = 0;

      p.attack = 40;
      p.hold = 140;
      p.decay = 140;
      p.holdValue = particleAlpha;
      p.lastValue = 0;

      p.stuckTime = 50 + Math.random() * 30;

      // index used for glow subsampling
      p._id = (Math.random() * 1e9) | 0;

      liveCount++;
      return p;
    }

    function recycle(p) {
      if (particleList.first === p) {
        particleList.first = p.next;
        if (p.next) p.next.prev = null;
      } else {
        if (p.prev) p.prev.next = p.next;
        if (p.next) p.next.prev = p.prev;
      }

      p.next = recycleBin.first;
      if (recycleBin.first) recycleBin.first.prev = p;
      recycleBin.first = p;
      p.prev = null;

      liveCount = Math.max(0, liveCount - 1);
    }

    function spawn() {
      if (liveCount >= maxParticles) return;

      const remaining = maxParticles - liveCount;
      const n = Math.min(particlesPerFrame, remaining);
      const scz = sphereCenterZ();

      for (let i = 0; i < n; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(Math.random() * 2 - 1);

        const x0 = sphereRad * Math.sin(phi) * Math.cos(theta);
        const y0 = sphereRad * Math.sin(phi) * Math.sin(theta);
        const z0 = sphereRad * Math.cos(phi);

        const locked = Math.random() < lockRatio;

        const x = x0;
        const y = y0;
        const z = scz + z0;

        const vx = locked ? 0 : driftVelocity * x0;
        const vy = locked ? 0 : driftVelocity * y0;
        const vz = locked ? 0 : driftVelocity * z0;

        addParticle(theta, phi, x, y, z, vx, vy, vz, locked);
      }
    }

    function lighting(nx, ny, nz) {
      let lit = nx * -0.35 + ny * -0.25 + nz * 0.9;
      lit = lit < 0 ? 0 : lit;
      return Math.pow(lit, 1.25);
    }

    // Render helper (fast LED squares)
    function drawDot(px, py, r) {
      if (!useSquares) {
        ctx.beginPath();
        ctx.arc(px, py, r, 0, Math.PI * 2);
        ctx.fill();
        return;
      }
      const s = Math.max(1, r | 0);
      ctx.fillRect(px - s * 0.5, py - s * 0.5, s, s);
    }

    function draw() {
      spawn();

      const now = performance.now();
      const dt = Math.min(0.05, (now - lastTime) / 1000);
      lastTime = now;

      phase += dt * shimmerSpeed;

      rotYaw = (rotYaw + yawSpeed) % (Math.PI * 2);
      rotPitch = (rotPitch + pitchSpeed) % (Math.PI * 2);
      rotRoll = (rotRoll + rollSpeed) % (Math.PI * 2);

      const cy = Math.cos(rotYaw),
        sy = Math.sin(rotYaw);
      const cx = Math.cos(rotPitch),
        sx = Math.sin(rotPitch);
      const cz = Math.cos(rotRoll),
        sz = Math.sin(rotRoll);

      // orbit axis rotates with orb (0,1,0 rotated)
      let ax = 0,
        ay = 1,
        az = 0;

      // pitch
      let ay1 = cx * ay - sx * az;
      let az1 = sx * ay + cx * az;
      let ax1 = ax;

      // yaw
      let ax2 = cy * ax1 + sy * az1;
      let az2 = -sy * ax1 + cy * az1;
      let ay2 = ay1;

      // roll
      let ax3 = cz * ax2 - sz * ay2;
      let ay3 = sz * ax2 + cz * ay2;
      let az3 = az2;

      const orbitAxisX = ax3;
      const orbitAxisY = ay3;
      const orbitAxisZ = az3;

      const scz = sphereCenterZ();

      ctx.clearRect(0, 0, displayWidth, displayHeight);
      ctx.globalCompositeOperation = cachedMode;

      // -------- PASS 1: base (NO glow) --------
      ctx.shadowBlur = 0;
      ctx.shadowColor = "transparent";

      let p = particleList.first;
      while (p) {
        const next = p.next;
        p.age++;

        if (!p.locked && p.age > p.stuckTime) {
          const dx = p.x;
          const dy = p.y;
          const dz = p.z - scz;

          const r = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;

          const nxr = dx / r;
          const nyr = dy / r;
          const nzr = dz / r;

          const dr = targetR - r;
          const axSpring = springK * dr * nxr;
          const aySpring = springK * dr * nyr;
          const azSpring = springK * dr * nzr;

          // tangent = axis × radial
          const t = cross(orbitAxisX, orbitAxisY, orbitAxisZ, nxr, nyr, nzr);
          const tl = Math.sqrt(t.x * t.x + t.y * t.y + t.z * t.z) || 1;
          let tx = t.x / tl,
            ty = t.y / tl,
            tz = t.z / tl;

          // optional corkscrew
          if (swirlMix > 0.001) {
            const t2 = cross(nxr, nyr, nzr, tx, ty, tz);
            const t2l = Math.sqrt(t2.x * t2.x + t2.y * t2.y + t2.z * t2.z) || 1;
            const sx2v = t2.x / t2l,
              sy2v = t2.y / t2l,
              sz2v = t2.z / t2l;

            const bx = tx * (1 - swirlMix) + sx2v * swirlMix;
            const by = ty * (1 - swirlMix) + sy2v * swirlMix;
            const bz = tz * (1 - swirlMix) + sz2v * swirlMix;

            const bl = Math.sqrt(bx * bx + by * by + bz * bz) || 1;
            tx = bx / bl;
            ty = by / bl;
            tz = bz / bl;
          }

          p.velX +=
            axSpring + orbitK * tx + driftJitter * (Math.random() * 2 - 1);
          p.velY +=
            aySpring +
            orbitK * ty +
            gravity +
            driftJitter * (Math.random() * 2 - 1);
          p.velZ +=
            azSpring + orbitK * tz + driftJitter * (Math.random() * 2 - 1);

          p.velX *= damping;
          p.velY *= damping;
          p.velZ *= damping;

          p.x += p.velX;
          p.y += p.velY;
          p.z += p.velZ;

          const r2 = p.x * p.x + p.y * p.y + (p.z - scz) * (p.z - scz);
          if (r2 > maxR * maxR) {
            recycle(p);
            p = next;
            continue;
          }
        }

        // rotate current position
        let x = p.x;
        let y = p.y;
        let z = p.z - scz;

        let y1p = cx * y - sx * z;
        let z1p = sx * y + cx * z;

        let x2p = cy * x + sy * z1p;
        let z2p = -sy * x + cy * z1p;

        let x3p = cz * x2p - sz * y1p;
        let y3p = sz * x2p + cz * y1p;

        const rotX = x3p;
        const rotY = y3p;
        const rotZ = z2p + scz;

        const m = (radiusSp * fLen * projectionScale) / (fLen - rotZ);
        const px = rotX * m + projCenterX;
        const py = rotY * m + projCenterY + centerYOffset;

        if (
          px < 0 ||
          px > displayWidth ||
          py < 0 ||
          py > displayHeight ||
          rotZ > zMax
        ) {
          if (!p.locked) recycle(p);
          p = next;
          continue;
        }

        // envelope
        if (p.age < p.attack + p.hold + p.decay) {
          if (p.age < p.attack) p.alpha = (p.holdValue / p.attack) * p.age;
          else if (p.age < p.attack + p.hold) p.alpha = p.holdValue;
          else {
            p.alpha =
              ((p.lastValue - p.holdValue) / p.decay) *
                (p.age - p.attack - p.hold) +
              p.holdValue;
          }
        } else {
          if (p.locked) {
            p.age = 0;
            p.alpha = 0;
          } else {
            recycle(p);
            p = next;
            continue;
          }
        }

        let depth = 1 - rotZ / zeroAlphaDepth;
        depth = depth < 0 ? 0 : depth > 1 ? 1 : depth;
        const depthAlpha = Math.pow(depth, 1.25);

        // lighting normal
        let nx, ny, nz;
        if (p.locked) {
          const sx0 = Math.sin(p.phi);
          nx = sx0 * Math.cos(p.theta);
          ny = sx0 * Math.sin(p.theta);
          nz = Math.cos(p.phi);

          let ny1n = cx * ny - sx * nz;
          let nz1n = sx * ny + cx * nz;

          let nx2n = cy * nx + sy * nz1n;
          let nz2n = -sy * nx + cy * nz1n;

          let nx3n = cz * nx2n - sz * ny1n;
          let ny3n = sz * nx2n + cz * ny1n;

          nx = nx3n;
          ny = ny3n;
          nz = nz2n;
        } else {
          nx = rotX / sphereRad;
          ny = rotY / sphereRad;
          nz = z2p / sphereRad;
        }

        const lit = lighting(nx, ny, nz);
        const lightingBoost = 0.35 + 0.85 * lit;

        const u = p.theta / (Math.PI * 2) + rotYaw / (Math.PI * 2);
        const v = p.phi / Math.PI;

        const tex = sampleTexture(u, v);

        let rgb = fallbackRGB;
        let texAlpha = 1;

        if (tex) {
          rgb = `${tex.r},${tex.g},${tex.b}`;
          texAlpha = tex.a;
        }

        const scan = Math.sin(phase + v * Math.PI * 14);
        const shimmer = 1 + shimmerStrength * scan;

        const baseA =
          texAlpha * p.alpha * depthAlpha * lightingBoost * materialStrength;

        const a = Math.max(0, Math.min(1, baseA * shimmer));
        ctx.fillStyle = `rgba(${rgb}, ${a})`;

        const nearBoost = 0.78 + depth * 0.52;
        drawDot(px, py, m * particleRad * nearBoost);

        p = next;
      }

      // -------- PASS 2: glow highlights only (dark mode) --------
      if (cachedGlow === "on") {
        ctx.shadowBlur = glowBlur;
        ctx.shadowColor = `rgba(255,255,255,0.55)`;

        // redraw a subset as glow “sparkle”
        let q = particleList.first;
        while (q) {
          // glow 1 in N particles
          if (q._id % glowEvery === 0) {
            const scz2 = scz;

            let x = q.x;
            let y = q.y;
            let z = q.z - scz2;

            let y1p = cx * y - sx * z;
            let z1p = sx * y + cx * z;

            let x2p = cy * x + sy * z1p;
            let z2p = -sy * x + cy * z1p;

            let x3p = cz * x2p - sz * y1p;
            let y3p = sz * x2p + cz * y1p;

            const rotX = x3p;
            const rotY = y3p;
            const rotZ = z2p + scz2;

            const m = (radiusSp * fLen * projectionScale) / (fLen - rotZ);
            const px = rotX * m + projCenterX;
            const py = rotY * m + projCenterY + centerYOffset;

            if (
              px >= 0 &&
              px <= displayWidth &&
              py >= 0 &&
              py <= displayHeight &&
              rotZ <= zMax
            ) {
              let depth = 1 - rotZ / zeroAlphaDepth;
              depth = depth < 0 ? 0 : depth > 1 ? 1 : depth;

              // glow alpha is cheaper and simpler: rely on existing alpha + depth
              const a = Math.min(1, q.alpha * depth * glowStrength);
              ctx.fillStyle = `rgba(255,255,255, ${a})`;

              const nearBoost = 0.78 + depth * 0.52;
              drawDot(px, py, m * particleRad * nearBoost);
            }
          }
          q = q.next;
        }
      }

      ctx.shadowBlur = 0;
      ctx.shadowColor = "transparent";
      ctx.globalCompositeOperation = "source-over";

      raf = requestAnimationFrame(draw);
    }

    if (!reduceMotion) draw();

    window.addEventListener(
      "astro:before-swap",
      () => {
        cancelAnimationFrame(raf);
        moTheme.disconnect();
        moWrap.disconnect();
        window.__orbLedMounted.delete(uid);
      },
      { once: true },
    );
  })();
</script>

<style>
  .orb-led-wrap {
    display: flex;
    justify-content: center;
    align-items: center;
    color: inherit;
  }

  canvas {
    display: block;
    max-width: 100%;
    height: auto;
    background: transparent;
  }

  :global(html.dark) {
    --ps-composite-mode: lighter;
    --ps-glow: on;
  }

  :global(html.light) {
    --ps-composite-mode: multiply;
    --ps-glow: off;
  }
</style>
