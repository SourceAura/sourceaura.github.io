---
import type { CollectionEntry } from "astro:content";

interface Props {
  post: CollectionEntry<"petals">;
  type?: "text" | "audio" | "video" | "photo" | "project";

  width?: number;
  height?: number;

  sphereRad?: number;
  projectionScale?: number;
  radiusSp?: number;

  // Density
  particlesPerFrame?: number;
  maxParticles?: number;
  particleRad?: number;

  // Rotation speeds
  yawSpeed?: number;
  pitchSpeed?: number;
  rollSpeed?: number;

  // Dark glow tuning
  glowBlur?: number;
  glowStrength?: number;

  // Material strength
  materialStrength?: number;

  // Scanline shimmer
  shimmerStrength?: number;
  shimmerSpeed?: number;

  // Gamma correction (dark mode pop)
  gammaDark?: number;

  // Drift physics controls
  lockRatio?: number;
  driftVelocity?: number;
  driftJitter?: number;
  gravity?: number;
  maxDriftRadius?: number;

  // Spring + orbit controls
  springK?: number;
  damping?: number;
  orbitK?: number;
  targetRadiusMul?: number;

  // Field-line swirl
  swirlMix?: number;

  // Performance knobs
  glowEvery?: number;
  useSquares?: boolean;

  // Depth scaling controls
  depthScaleStrength?: number;
  depthBrightStrength?: number;

  // Dithering + contrast controls
  ditherStrength?: number;
  ditherContrast?: number;

  // Backface fade controls
  backfaceMin?: number;
  backfaceStrength?: number;

  // Rim light controls
  rimStrength?: number;
  rimPower?: number;

  // NEW: visibility guards
  minPixelAlpha?: number; // absolute minimum alpha for any LED
  minBackfaceAlpha?: number; // minimum alpha multiplier for the back side
  ignoreTextureAlpha?: boolean; // treat texture alpha as 1 (recommended)
}

const {
  post,
  width = 720,
  height = 416,

  sphereRad = 210,
  radiusSp = 1,
  projectionScale = 0.88,

  particlesPerFrame = 42,
  maxParticles = 2600,
  particleRad = 1.35,

  glowBlur = 6,
  glowStrength = 0.45,

  yawSpeed = (2 * Math.PI) / 1400,
  pitchSpeed = (2 * Math.PI) / 2200,
  rollSpeed = (2 * Math.PI) / 3000,

  materialStrength = 1,

  shimmerStrength = 0.08,
  shimmerSpeed = 1.6,

  gammaDark = 0.86,

  lockRatio = 0.88,
  driftVelocity = 0.0018,
  driftJitter = 0.06,
  gravity = 0,
  maxDriftRadius = 2.6,

  springK = 0.0022,
  damping = 0.985,
  orbitK = 0.0014,
  targetRadiusMul = 1.02,

  swirlMix = 0.18,

  glowEvery = 6,
  useSquares = true,

  depthScaleStrength = 0.55,
  depthBrightStrength = 0.22,

  // Make dithering less “hole-punchy” by default
  ditherStrength = 0.45,
  ditherContrast = 1.25,

  // Backface/rim tuned to shape, not vanish
  backfaceMin = 0.35,
  backfaceStrength = 0.65,

  rimStrength = 0.22,
  rimPower = 2.2,

  // Visibility guards (these are the key fixes)
  minPixelAlpha = 0.12,
  minBackfaceAlpha = 0.35,
  ignoreTextureAlpha = true,
} = Astro.props;

/* Extract first markdown image */
let imageSrc: string | null = null;
const match = post.body.match(/!\[.*?\]\((.*?)\)/);
if (match?.[1]) {
  const raw = match[1].trim();
  imageSrc =
    raw.startsWith("http") || raw.startsWith("/")
      ? raw
      : `/images/${raw.replace(/^\.?\//, "")}`;
}

const uid = `orb_${Math.random().toString(16).slice(2)}`;
const canvasId = `${uid}_canvas`;
---

<div class="orb-led-wrap" data-orb-led-root={uid}>
  <canvas id={canvasId} width={width} height={height}></canvas>
</div>

<script
  is:inline
  define:vars={{
    uid,
    canvasId,
    sphereRad,
    radiusSp,
    projectionScale,
    particlesPerFrame,
    maxParticles,
    particleRad,
    glowBlur,
    glowStrength,
    yawSpeed,
    pitchSpeed,
    rollSpeed,
    imageSrc,
    materialStrength,
    shimmerStrength,
    shimmerSpeed,
    gammaDark,
    lockRatio,
    driftVelocity,
    driftJitter,
    gravity,
    maxDriftRadius,
    springK,
    damping,
    orbitK,
    targetRadiusMul,
    swirlMix,
    glowEvery,
    useSquares,
    depthScaleStrength,
    depthBrightStrength,
    ditherStrength,
    ditherContrast,
    backfaceMin,
    backfaceStrength,
    rimStrength,
    rimPower,
    minPixelAlpha,
    minBackfaceAlpha,
    ignoreTextureAlpha,
  }}
>
  (() => {
    window.__orbMounted ??= new Set();
    if (window.__orbMounted.has(uid)) return;
    window.__orbMounted.add(uid);

    const canvas = document.getElementById(canvasId);
    const ctx = canvas?.getContext("2d");
    if (!canvas || !ctx) return;

    const reduceMotion = matchMedia("(prefers-reduced-motion: reduce)").matches;

    const w = canvas.width;
    const h = canvas.height;

    const fLen = 320;
    const projCenterX = w / 2;
    const projCenterY = h / 2;
    const centerYOffset = -sphereRad * 0.15;
    const zMax = fLen - 2;

    const particleList = { first: null };
    const recycleBin = { first: null };
    let liveCount = 0;

    const sphereCenterZ = () => -3 - sphereRad;
    const targetR = sphereRad * targetRadiusMul;
    const maxR = sphereRad * maxDriftRadius;

    let rotYaw = 0,
      rotPitch = 0,
      rotRoll = 0;
    let lastTime = performance.now();
    let phase = 0;

    let cachedMode = "source-over";
    let cachedGlow = "off";
    let isDark = false;
    let fallbackRGB = "255,255,255";

    function refreshTheme() {
      const root = getComputedStyle(document.documentElement);
      cachedMode =
        root.getPropertyValue("--ps-composite-mode").trim() || "source-over";
      cachedGlow = root.getPropertyValue("--ps-glow").trim() || "off";
      isDark = document.documentElement.classList.contains("dark");

      const wrap = document.querySelector(`[data-orb-led-root="${uid}"]`);
      const c = getComputedStyle(wrap ?? document.documentElement).color;
      const m = c.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      fallbackRGB = m
        ? `${m[1]},${m[2]},${m[3]}`
        : isDark
          ? "255,255,255"
          : "0,0,0";
    }

    refreshTheme();
    const moTheme = new MutationObserver(refreshTheme);
    moTheme.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["class", "style"],
    });

    function cross(ax, ay, az, bx, by, bz) {
      return {
        x: ay * bz - az * by,
        y: az * bx - ax * bz,
        z: ax * by - ay * bx,
      };
    }

    function clamp01(v) {
      return v < 0 ? 0 : v > 1 ? 1 : v;
    }

    // Ordered dithering (Bayer 4x4)
    const BAYER4 = [
      [0, 8, 2, 10],
      [12, 4, 14, 6],
      [3, 11, 1, 9],
      [15, 7, 13, 5],
    ];
    function bayerThreshold(x, y) {
      return (BAYER4[y & 3][x & 3] + 0.5) / 16;
    }

    // Texture sampling
    let texReady = false,
      texW = 0,
      texH = 0,
      texData = null;

    if (imageSrc) {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.decoding = "async";
      img.loading = "eager";
      img.src = imageSrc;
      img.onload = () => {
        const maxDim = 384;
        const scale = Math.min(
          1,
          maxDim / Math.max(img.naturalWidth, img.naturalHeight),
        );
        texW = Math.max(1, (img.naturalWidth * scale) | 0);
        texH = Math.max(1, (img.naturalHeight * scale) | 0);

        const c = document.createElement("canvas");
        c.width = texW;
        c.height = texH;
        const ictx = c.getContext("2d", { willReadFrequently: true });
        if (!ictx) return;
        ictx.drawImage(img, 0, 0, texW, texH);
        texData = ictx.getImageData(0, 0, texW, texH).data;
        texReady = true;
      };
    }

    function sample(u, v) {
      if (!texReady || !texData) return null;

      u -= Math.floor(u);
      v = v < 0 ? 0 : v > 1 ? 1 : v;

      const x = (u * (texW - 1)) | 0;
      const y = (v * (texH - 1)) | 0;
      const i = (y * texW + x) * 4;

      let r = texData[i];
      let g = texData[i + 1];
      let b = texData[i + 2];
      const a = texData[i + 3] / 255;

      if (isDark && gammaDark !== 1) {
        const inv = 1 / 255;
        r = (255 * Math.pow(r * inv, gammaDark)) | 0;
        g = (255 * Math.pow(g * inv, gammaDark)) | 0;
        b = (255 * Math.pow(b * inv, gammaDark)) | 0;
      }
      return { r, g, b, a };
    }

    // Fibonacci spawn
    let spawnIndex = 0;
    const golden = Math.PI * (3 - Math.sqrt(5));

    function addParticle(theta, phi, x, y, z, vx, vy, vz, locked) {
      let p = recycleBin.first || {};
      if (recycleBin.first) {
        recycleBin.first = p.next;
        if (p.next) p.next.prev = null;
      }

      p.next = particleList.first;
      if (particleList.first) particleList.first.prev = p;
      particleList.first = p;
      p.prev = null;

      p.theta = theta;
      p.phi = phi;

      p.x = x;
      p.y = y;
      p.z = z;
      p.vx = vx;
      p.vy = vy;
      p.vz = vz;

      p.locked = !!locked;

      p.age = 0;
      p.stuck = 45 + Math.random() * 25;
      p.life = 520 + Math.random() * 220;

      p.id = (Math.random() * 1e9) | 0;

      liveCount++;
      return p;
    }

    function recycle(p) {
      if (particleList.first === p) {
        particleList.first = p.next;
        if (p.next) p.next.prev = null;
      } else {
        if (p.prev) p.prev.next = p.next;
        if (p.next) p.next.prev = p.prev;
      }

      p.next = recycleBin.first;
      if (recycleBin.first) recycleBin.first.prev = p;
      recycleBin.first = p;
      p.prev = null;

      liveCount = Math.max(0, liveCount - 1);
    }

    function spawn() {
      if (liveCount >= maxParticles) return;

      const remaining = maxParticles - liveCount;
      const n = Math.min(particlesPerFrame, remaining);
      const scz = sphereCenterZ();

      for (let i = 0; i < n; i++) {
        const k = spawnIndex++;
        const t = (k + 0.5) / maxParticles;
        const yN = 1 - 2 * t;
        const rN = Math.sqrt(Math.max(0, 1 - yN * yN));
        const ang = golden * k;

        const nx = Math.cos(ang) * rN;
        const ny = yN;
        const nz = Math.sin(ang) * rN;

        const theta = Math.atan2(nz, nx);
        const phi = Math.acos(ny);

        const x0 = sphereRad * nx;
        const y0 = sphereRad * ny;
        const z0 = sphereRad * nz;

        const locked = Math.random() < lockRatio;

        addParticle(
          theta < 0 ? theta + Math.PI * 2 : theta,
          phi,
          x0,
          y0,
          scz + z0,
          locked ? 0 : driftVelocity * x0,
          locked ? 0 : driftVelocity * y0,
          locked ? 0 : driftVelocity * z0,
          locked,
        );
      }
    }

    function drawDot(x, y, size) {
      if (!useSquares) {
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
        return;
      }
      const s = Math.max(1, size | 0);
      ctx.fillRect(x - s * 0.5, y - s * 0.5, s, s);
    }

    function rotateVec(x, y, z, cyp, syp, cxp, sxp, czp, szp) {
      // pitch
      const y1 = cxp * y - sxp * z;
      const z1 = sxp * y + cxp * z;
      // yaw
      const x2 = cyp * x + syp * z1;
      const z2 = -syp * x + cyp * z1;
      // roll
      const x3 = czp * x2 - szp * y1;
      const y3 = szp * x2 + czp * y1;
      return { x: x3, y: y3, z: z2 };
    }

    function draw() {
      spawn();

      const now = performance.now();
      const dt = Math.min(0.05, (now - lastTime) / 1000);
      lastTime = now;
      phase += dt * shimmerSpeed;

      rotYaw += yawSpeed;
      rotPitch += pitchSpeed;
      rotRoll += rollSpeed;

      const cyp = Math.cos(rotYaw),
        syp = Math.sin(rotYaw);
      const cxp = Math.cos(rotPitch),
        sxp = Math.sin(rotPitch);
      const czp = Math.cos(rotRoll),
        szp = Math.sin(rotRoll);

      // orbit axis is rotated world-up
      const up = rotateVec(0, 1, 0, cyp, syp, cxp, sxp, czp, szp);
      const orbitAxisX = up.x,
        orbitAxisY = up.y,
        orbitAxisZ = up.z;

      const scz = sphereCenterZ();

      ctx.clearRect(0, 0, w, h);
      ctx.globalCompositeOperation = cachedMode;

      // Base pass (no glow)
      ctx.shadowBlur = 0;
      ctx.shadowColor = "transparent";

      let p = particleList.first;
      while (p) {
        const next = p.next;

        // drift for non-locked
        if (!p.locked) {
          p.age++;
          if (p.age > p.stuck) {
            const dx = p.x,
              dy = p.y,
              dz = p.z - scz;

            const r = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;
            const nxr = dx / r,
              nyr = dy / r,
              nzr = dz / r;

            const dr = targetR - r;
            const axSpring = springK * dr * nxr;
            const aySpring = springK * dr * nyr;
            const azSpring = springK * dr * nzr;

            const t = cross(orbitAxisX, orbitAxisY, orbitAxisZ, nxr, nyr, nzr);
            const tl = Math.sqrt(t.x * t.x + t.y * t.y + t.z * t.z) || 1;
            let tx = t.x / tl,
              ty = t.y / tl,
              tz = t.z / tl;

            if (swirlMix > 0.001) {
              const t2 = cross(nxr, nyr, nzr, tx, ty, tz);
              const t2l =
                Math.sqrt(t2.x * t2.x + t2.y * t2.y + t2.z * t2.z) || 1;
              const sx2 = t2.x / t2l,
                sy2 = t2.y / t2l,
                sz2 = t2.z / t2l;

              const bx = tx * (1 - swirlMix) + sx2 * swirlMix;
              const by = ty * (1 - swirlMix) + sy2 * swirlMix;
              const bz = tz * (1 - swirlMix) + sz2 * swirlMix;

              const bl = Math.sqrt(bx * bx + by * by + bz * bz) || 1;
              tx = bx / bl;
              ty = by / bl;
              tz = bz / bl;
            }

            p.vx +=
              axSpring + orbitK * tx + driftJitter * (Math.random() * 2 - 1);
            p.vy +=
              aySpring +
              orbitK * ty +
              gravity +
              driftJitter * (Math.random() * 2 - 1);
            p.vz +=
              azSpring + orbitK * tz + driftJitter * (Math.random() * 2 - 1);

            p.vx *= damping;
            p.vy *= damping;
            p.vz *= damping;

            p.x += p.vx;
            p.y += p.vy;
            p.z += p.vz;

            const r2 = p.x * p.x + p.y * p.y + (p.z - scz) * (p.z - scz);
            if (r2 > maxR * maxR || p.age > p.life) {
              recycle(p);
              p = next;
              continue;
            }
          }
        }

        // rotate position
        const localZ = p.z - scz;
        const pr = rotateVec(p.x, p.y, localZ, cyp, syp, cxp, sxp, czp, szp);

        const rotX = pr.x;
        const rotY = pr.y;
        const rotZ = pr.z + scz;

        if (rotZ > zMax) {
          p = next;
          continue;
        }

        const m = (radiusSp * fLen * projectionScale) / (fLen - rotZ);
        const px = rotX * m + projCenterX;
        const py = rotY * m + projCenterY + centerYOffset;

        if (px < 0 || px > w || py < 0 || py > h) {
          p = next;
          continue;
        }

        // depth (stable heuristic)
        let depth = 1 - rotZ / -750;
        depth = clamp01(depth);

        // normal z in view space for backface/rim
        let nxl, nyl, nzl;
        if (p.locked) {
          const s = Math.sin(p.phi);
          nxl = s * Math.cos(p.theta);
          nyl = s * Math.sin(p.theta);
          nzl = Math.cos(p.phi);
        } else {
          const invR = 1 / sphereRad;
          nxl = p.x * invR;
          nyl = p.y * invR;
          nzl = localZ * invR;
        }

        const nr = rotateVec(nxl, nyl, nzl, cyp, syp, cxp, sxp, czp, szp);
        const nzView = nr.z; // + = facing viewer-ish

        // Backface fade (safe)
        const faceFactor = clamp01((nzView + 1) * 0.5);
        const backFadeRaw =
          backfaceMin +
          (1 - backfaceMin) *
            (1 - backfaceStrength + backfaceStrength * faceFactor);

        const backFade = Math.max(minBackfaceAlpha, backFadeRaw);

        // Rim light (safe)
        const rimBase = 1 - Math.min(1, Math.abs(nzView));
        const rim = Math.pow(clamp01(rimBase), rimPower);
        const rimBoost = 1 + rimStrength * rim;

        // Size scaling: front bigger
        const sizeBoost = 1 + depthScaleStrength * depth;
        const size = m * particleRad * sizeBoost;

        // UV scroll by yaw
        const u = p.theta / (Math.PI * 2) + rotYaw / (Math.PI * 2);
        const v = p.phi / Math.PI;

        const tex = sample(u, v);

        let r = 0,
          g = 0,
          b = 0,
          a = 1;

        if (tex) {
          r = tex.r;
          g = tex.g;
          b = tex.b;
          a = ignoreTextureAlpha ? 1 : tex.a;
        } else {
          const parts = fallbackRGB.split(",");
          r = +parts[0] || 0;
          g = +parts[1] || 0;
          b = +parts[2] || 0;
          a = 1;
        }

        // Dither based on luminance (but never fully “off”)
        let lum = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
        lum = clamp01((lum - 0.5) * ditherContrast + 0.5);

        const thr = bayerThreshold(px | 0, py | 0);
        const mask = lum > thr ? 1 : 0;
        const ditherAlpha =
          1 - ditherStrength + ditherStrength * (0.38 + 0.62 * mask);

        // shimmer
        const scan = Math.sin(phase + v * Math.PI * 14);
        const shimmer = 1 + shimmerStrength * scan;

        // front bright
        const brightBoost = 1 + depthBrightStrength * depth;

        // FINAL ALPHA (with hard floor)
        const computedA =
          a *
          materialStrength *
          shimmer *
          ditherAlpha *
          brightBoost *
          backFade *
          rimBoost;

        const finalA = Math.max(minPixelAlpha, clamp01(computedA));

        ctx.fillStyle = `rgba(${r},${g},${b},${finalA})`;
        drawDot(px, py, size);

        p = next;
      }

      // Glow pass (dark only)
      if (cachedGlow === "on") {
        ctx.shadowBlur = glowBlur;
        ctx.shadowColor = `rgba(255,255,255,0.55)`;

        let q = particleList.first;
        while (q) {
          if (q.id % glowEvery === 0) {
            const localZ2 = q.z - scz;
            const pr2 = rotateVec(
              q.x,
              q.y,
              localZ2,
              cyp,
              syp,
              cxp,
              sxp,
              czp,
              szp,
            );
            const rotZ2 = pr2.z + scz;

            if (rotZ2 <= zMax) {
              const m2 = (radiusSp * fLen * projectionScale) / (fLen - rotZ2);
              const px2 = pr2.x * m2 + projCenterX;
              const py2 = pr2.y * m2 + projCenterY + centerYOffset;

              if (px2 >= 0 && px2 <= w && py2 >= 0 && py2 <= h) {
                let depth2 = 1 - rotZ2 / -750;
                depth2 = clamp01(depth2);

                // simpler shaping, still safe
                const a2 = Math.max(0.08, depth2 * glowStrength);
                ctx.fillStyle = `rgba(255,255,255,${a2})`;

                const sizeBoost2 = 1 + depthScaleStrength * depth2;
                drawDot(px2, py2, m2 * particleRad * sizeBoost2);
              }
            }
          }
          q = q.next;
        }

        ctx.shadowBlur = 0;
        ctx.shadowColor = "transparent";
      }

      ctx.globalCompositeOperation = "source-over";
      requestAnimationFrame(draw);
    }

    if (!reduceMotion) draw();

    window.addEventListener(
      "astro:before-swap",
      () => {
        moTheme.disconnect();
        window.__orbMounted.delete(uid);
      },
      { once: true },
    );
  })();
</script>

<style>
  .orb-led-wrap {
    display: flex;
    justify-content: center;
    align-items: center;
    color: inherit;
  }

  canvas {
    display: block;
    max-width: 100%;
    height: auto;
    background: transparent;
  }

  :global(html.dark) {
    --ps-composite-mode: lighter;
    --ps-glow: on;
  }

  :global(html.light) {
    --ps-composite-mode: multiply;
    --ps-glow: off;
  }
</style>
