---
/* Nelumbo
Rose Lotus - Rotating LED Display.
Nelumbo is a component that displays a carousel of petals.

Interaction:
- Double click OR long press on the ACTIVE petal/orb to open the HUD.
- Esc / click outside / gesture:close-petals closes.

HUD layout (under PageFind input):
- Left column: Title (top), Image (below), Description (below)
- Right column: Article content
- Bottom: Stat cluster (date + read time + open link)

Notes:
- “Scanline” only applies to the image block.
- No HUD border (clean HUD segments).
- Side-profile hiding keeps petals from showing “flat” edges.
*/
import Orb from "@components/Orb.astro";
import type { CollectionEntry } from "astro:content";
import { readingTime } from "@utils/utils";

const { posts } = Astro.props as { posts: CollectionEntry<"petals">[] };

// Precompute per-post HUD assets (first image + rendered article)
const enriched = await Promise.all(
  posts.map(async (post) => {
    const { Content } = await post.render();

    // Extract first markdown image
    let imageSrc: string | null = null;
    const match = post.body.match(/!\[.*?\]\((.*?)\)/);
    if (match?.[1]) {
      const raw = match[1].trim();
      imageSrc =
        raw.startsWith("http") || raw.startsWith("/")
          ? raw
          : `/images/${raw.replace(/^\.?\//, "")}`;
    }

    const d = new Date(post.data.date);
    const dateLabel = d.toLocaleDateString(undefined, {
      month: "2-digit",
      day: "2-digit",
      year: "numeric",
    });

    const rt = `${readingTime(post.body)} min`;

    return {
      post,
      Content,
      imageSrc,
      dateLabel,
      rt,
      href: `/petals/${post.slug}`,
    };
  }),
);
---

<div class="carousel-layer" id="petal-shell">
  <div class="carousel-viewport" aria-label="Petal carousel">
    <div class="carousel-ring" id="petal-ring">
      {
        enriched.map((p, i) => (
          <div
            class="carousel-item"
            tabindex="0"
            data-index={i}
            data-href={p.href}
          >
            <div class="parallax-layer">
              <div class="petal-surface" data-open-hud>
                <Orb post={p.post} />
              </div>
            </div>
          </div>
        ))
      }
    </div>
  </div>

  {/* HUD Overlay (renders all panels; only active shows) */}
  <div class="hud-layer" id="hud-layer" aria-hidden="true">
    <div class="hud-scrim" data-hud-close></div>

    <section class="hud" role="dialog" aria-label="Petal HUD" aria-modal="true">
      <button class="hud-close" type="button" aria-label="Close" data-hud-close>
        ✕
      </button>

      <div class="hud-grid">
        {
          enriched.map((p, i) => (
            <article class="hud-panel" data-hud-panel data-index={i}>
              {/* Title (above image, top-left, just under PageFind input) */}
              <header class="hud-title">
                <h2>{p.post.data.title}</h2>

                <a class="hud-open" href={p.href} aria-label="Open post">
                  OPEN
                  <span aria-hidden="true">↗</span>
                </a>
              </header>

              {/* Left column (image + description) */}
              <div class="hud-left">
                <div class="hud-image-wrap">
                  {p.imageSrc ? (
                    <img
                      class="hud-image"
                      src={p.imageSrc}
                      alt={p.post.data.title}
                      loading="eager"
                      decoding="async"
                    />
                  ) : (
                    <div class="hud-image-fallback" aria-hidden="true" />
                  )}
                </div>

                {p.post.data.description && (
                  <p class="hud-desc">{p.post.data.description}</p>
                )}
              </div>

              {/* Right column (article content) */}
              <div class="hud-right">
                <div
                  class="hud-article prose dark:prose-invert"
                  data-hud-article
                >
                  <p.Content />
                </div>
              </div>

              {/* Bottom cluster (stats) */}
              <footer class="hud-stats" aria-label="Post stats">
                <div class="hud-stat">
                  <span class="hud-k">DATE</span>
                  <span class="hud-v">{p.dateLabel}</span>
                </div>
                <div class="hud-stat">
                  <span class="hud-k">READ</span>
                  <span class="hud-v">{p.rt}</span>
                </div>
                <div class="hud-stat">
                  <span class="hud-k">TYPE</span>
                  <span class="hud-v">PETAL</span>
                </div>
              </footer>
            </article>
          ))
        }
      </div>
    </section>
  </div>

  <div class="carousel-hint" aria-hidden="true"></div>
</div>

<script>
  const shell = document.getElementById("petal-shell");
  const ring = document.getElementById("petal-ring");
  const items = ring ? [...ring.querySelectorAll(".carousel-item")] : [];
  const hudLayer = document.getElementById("hud-layer");
  const panels = hudLayer
    ? [...hudLayer.querySelectorAll("[data-hud-panel]")]
    : [];
  const closeEls = hudLayer
    ? [...hudLayer.querySelectorAll("[data-hud-close]")]
    : [];

  const count = items.length;
  const step = count ? 360 / count : 360;

  // E.T. Phone Home (homepage display-only)
  const onHome = location.pathname === "/";
  if (onHome && shell) {
    shell.addEventListener(
      "click",
      (e) => {
        e.preventDefault();
        e.stopPropagation();
      },
      true,
    );
  }

  /* ───────── VISIBILITY STATE ───────── */
  let petalsOpen = false;

  function updatePetalVisibility() {
    if (!shell) return;
    shell.toggleAttribute("data-petals-open", petalsOpen);
    if (!petalsOpen) focusedIndex = -1;
  }

  /* ───────── Base physics ───────── */
  const BASE_FRICTION = 0.96;
  const BASE_SNAP = 0.06;
  const velClamp = 3.2;
  const settleThreshold = 0.015;

  let isRevealed = false;
  let angle = 0;
  let vel = 0;
  let isDragging = false;

  let lastAngle = null;
  let lastActive = -1;

  let focusedIndex = -1;
  let snapTarget = null;
  let snapElastic = 0;

  let rafId = 0;
  let running = false;

  // ── ACTIVE PETAL OUTWARD PULL (kept for the carousel feel) ──
  const REVEAL_THRESHOLD = 96;
  const KEY_PULL_STEP = 14;
  const KEY_PULL_MAX = 140;

  let pullZ = 0;
  let pullVel = 0;
  let isPulling = false;

  function closeRevealedPetal() {
    if (!isRevealed || !shell) return;
    isRevealed = false;
    isPulling = false;
    pullZ = 0;
    pullVel = 0;
    shell.removeAttribute("data-revealed");
    start();
  }

  /* ───────────────── OM PULSE (GLOBAL) ───────────────── */
  function getOmPulse() {
    const v = getComputedStyle(document.documentElement).getPropertyValue(
      "--pulse",
    );
    const p = Number(v);
    return Number.isFinite(p) ? p : 0.5;
  }

  /* ───────────────── RADIUS (CACHED) ───────────────── */
  let radius = 300;
  const mq = matchMedia("(max-width: 768px)");
  function updateRadius() {
    radius = mq.matches ? 220 : 300;
  }
  mq.addEventListener("change", updateRadius);
  updateRadius();

  /* Helpers */
  const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
  const snapAngle = (a) => Math.round(a / step) * step;

  // normalize degrees to [0..360)
  const normDeg = (d) => ((d % 360) + 360) % 360;

  // smallest angular distance between a and b (degrees)
  const angDist = (a, b) => {
    const d = Math.abs(a - b) % 360;
    return d > 180 ? 360 - d : d;
  };

  // smoothstep for nicer fades
  const smoothstep = (e0, e1, x) => {
    const t = Math.max(0, Math.min(1, (x - e0) / (e1 - e0)));
    return t * t * (3 - 2 * t);
  };

  // Side-hide tuning (degrees around profile)
  const SIDE_KILL = 43;
  const SIDE_FADE_END = 52;

  function snapToIndex(index, immediate = false) {
    const target = -index * step;
    snapTarget = target;

    if (immediate) {
      angle = target;
      vel = 0;
      snapElastic = 0;
      applyTransforms();
      start();
      return;
    }

    const delta = target - angle;
    snapElastic = clamp(delta * 0.12, -18, 18);
    vel = 0;
    start();
  }

  /* ───────────────── HUD controls ───────────────── */
  let hudOpen = false;
  let hudIndex = 0;

  function setHudIndex(i) {
    hudIndex = i;
    panels.forEach((p) => {
      const idx = Number(p.getAttribute("data-index"));
      p.toggleAttribute("data-active", idx === hudIndex);
    });
  }

  function openHud(i) {
    if (!hudLayer) return;
    hudOpen = true;
    setHudIndex(i);
    hudLayer.setAttribute("data-open", "");
    hudLayer.removeAttribute("aria-hidden");
    // stop carousel motion while HUD is open (prevents “drift” while reading)
    vel = 0;
    running = false;
    cancelAnimationFrame(rafId);
    applyTransforms();
  }

  function closeHud() {
    if (!hudLayer) return;
    hudOpen = false;
    hudLayer.removeAttribute("data-open");
    hudLayer.setAttribute("aria-hidden", "true");
    // resume carousel loop
    start();
  }

  closeEls.forEach((el) => el.addEventListener("click", closeHud));

  window.addEventListener("keydown", (e) => {
    if (e.key !== "Escape") return;

    if (hudOpen) {
      closeHud();
      return;
    }

    if (isRevealed) {
      closeRevealedPetal();
      return;
    }

    if (petalsOpen) {
      isPulling = false;
      pullVel = 0;
      petalsOpen = false;
      updatePetalVisibility();
    }
  });

  window.addEventListener("gesture:close-petals", () => {
    if (hudOpen) closeHud();
    isPulling = false;
    pullVel = 0;
    petalsOpen = false;
    updatePetalVisibility();
  });

  // Touch/click outside viewport to close (also closes HUD)
  window.addEventListener(
    "pointerdown",
    (e) => {
      if (hudOpen) {
        // if clicking inside hud, ignore
        if (e.target.closest(".hud")) return;
        closeHud();
        return;
      }

      if (e.target.closest(".carousel-item.active")) return;

      if (isRevealed) {
        closeRevealedPetal();
        return;
      }

      if (petalsOpen) {
        isPulling = false;
        pullVel = 0;
        petalsOpen = false;
        updatePetalVisibility();
      }
    },
    { passive: true },
  );

  /* ───────────────── TRANSFORMS ───────────────── */
  function applyTransforms() {
    if (!ring) return;
    if (angle === lastAngle) return;
    lastAngle = angle;

    const om = getOmPulse();

    ring.style.transform = `translateZ(0) rotateY(${angle + snapElastic}deg)`;

    const normalized = ((angle % 360) + 360) % 360;
    const active = ((Math.round(-normalized / step) % count) + count) % count;

    if (active !== lastActive) {
      lastActive = active;
      items.forEach((el, i) => el.classList.toggle("active", i === active));
    }

    const maxDist = Math.floor(count / 2 || 1);

    items.forEach((el, i) => {
      let dist = Math.abs(i - active);
      dist = Math.min(dist, count - dist);

      const depth = Math.min(1, dist / maxDist);

      // Side-profile hiding
      const yaw = normDeg(i * step + angle + snapElastic);
      const sideDist = Math.min(angDist(yaw, 90), angDist(yaw, 270));
      const sideVis = smoothstep(SIDE_KILL, SIDE_FADE_END, sideDist);

      const depthVis = 1 - depth * 0.7;
      const finalVis = depthVis * sideVis;

      el.style.opacity = finalVis.toFixed(3);

      // scale: depth scale + small edge-on shrink
      const baseScale = 1 - depth * 0.12;
      const sideScale = 0.88 + 0.12 * sideVis;

      el.style.setProperty("--panel-scale", (baseScale * sideScale).toFixed(4));

      // disable interaction when basically invisible
      el.style.pointerEvents = sideVis < 0.08 ? "none" : "auto";
      el.style.visibility = sideVis < 0.02 ? "hidden" : "visible";

      const activeBias = i === active ? 22 + (om - 0.5) * 10 : 0;
      const pull = i === active ? pullZ : 0;

      el.style.transform = `translate(-50%, -50%)
         rotateY(${i * step}deg)
         translateZ(${radius + activeBias + pull}px)`;
    });
  }

  /* ───────────────── RAF LOOP (IDLE-AWARE + OM-SYNCED) ───────────────── */
  function tick() {
    if (!running) return;

    // if HUD is open, pause carousel
    if (hudOpen) {
      running = false;
      applyTransforms();
      return;
    }

    const om = getOmPulse();
    const breath = (om - 0.5) * 2;

    const friction = BASE_FRICTION * (1 - breath * 0.015);
    const snapStrength = BASE_SNAP * (1 + breath * 0.06);

    if (!isRevealed) {
      angle += vel;
      vel *= friction;
    } else {
      vel = 0;
      angle = snapAngle(angle);
    }

    if (snapTarget !== null) {
      const d = snapTarget - angle;
      angle += d * snapStrength;
      snapElastic *= 0.78;

      if (Math.abs(d) < 0.01 && Math.abs(snapElastic) < 0.2) {
        angle = snapTarget;
        vel = 0;
        snapElastic = 0;
        snapTarget = null;
      }
    }

    // Outward pull relax
    if (!isPulling) {
      pullVel *= 0.82;
      pullZ += pullVel;
      pullZ += (0 - pullZ) * 0.12;

      if (!isRevealed && pullZ >= REVEAL_THRESHOLD && shell) {
        isRevealed = true;
        pullVel = 0;
        vel = 0;
        shell.setAttribute("data-revealed", "");
      }

      if (isRevealed && pullZ < REVEAL_THRESHOLD * 0.6 && shell) {
        isRevealed = false;
        shell.removeAttribute("data-revealed");
      }

      if (Math.abs(pullZ) < 0.2) {
        pullZ = 0;
        pullVel = 0;
      }
    }

    if (snapTarget === null && Math.abs(vel) < settleThreshold) {
      const snapped = snapAngle(angle);
      angle += (snapped - angle) * snapStrength;

      if (Math.abs(snapped - angle) < 0.001) {
        angle = snapped;
        vel = 0;
        running = false;
        applyTransforms();
        return;
      }
    }

    applyTransforms();
    rafId = requestAnimationFrame(tick);
  }

  function start() {
    if (running) return;
    running = true;
    rafId = requestAnimationFrame(tick);
  }

  /* ───────────────── INPUT ───────────────── */
  function ensureOpen() {
    if (!petalsOpen) {
      petalsOpen = true;
      updatePetalVisibility();
      start();
    }
  }

  // Drag still rotates carousel
  shell?.addEventListener(
    "pointermove",
    (e) => {
      if (!isDragging || hudOpen) return;

      if (!isPulling) {
        vel = clamp(e.movementX * 0.12, -velClamp, velClamp);
        angle += e.movementX * 0.12;
      }

      if (e.movementY < -1) {
        isPulling = true;
      }

      if (isPulling) {
        pullVel = clamp(-e.movementY * 0.6, -8, 14);
        pullZ = clamp(pullZ + pullVel, 0, 140);
      }

      start();
    },
    { passive: true },
  );

  shell?.addEventListener(
    "pointerup",
    () => {
      isDragging = false;
      isPulling = false;
    },
    { passive: true },
  );

  // Double click + Long press: open HUD on ACTIVE item
  let pressTimer = 0;
  let pressStart = 0;
  const LONG_PRESS_MS = 420;

  function armLongPress(index, el) {
    clearTimeout(pressTimer);
    pressStart = performance.now();

    pressTimer = window.setTimeout(() => {
      // only open if still active and visible
      if (!el.classList.contains("active")) return;
      openHud(index);
    }, LONG_PRESS_MS);
  }

  function disarmLongPress() {
    clearTimeout(pressTimer);
    pressTimer = 0;
  }

  items.forEach((el) => {
    const index = Number(el.dataset.index);

    // Pointer down: focus + snap (like before)
    el.addEventListener(
      "pointerdown",
      (e) => {
        if (e.pointerType === "mouse" && e.button !== 0) return;

        e.preventDefault();
        e.stopPropagation();

        ensureOpen();

        focusedIndex = index;
        snapToIndex(index, false);

        isDragging = true;
        isPulling = false;
        pullVel = 0;

        el.setPointerCapture?.(e.pointerId);

        // long press only for the active petal surface
        armLongPress(index, el);

        start();
      },
      { passive: false },
    );

    el.addEventListener("pointerup", disarmLongPress, { passive: true });
    el.addEventListener("pointercancel", disarmLongPress, { passive: true });
    el.addEventListener("pointerleave", disarmLongPress, { passive: true });

    // Double click opens HUD if this becomes active
    el.addEventListener(
      "dblclick",
      (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!el.classList.contains("active")) return;
        openHud(index);
      },
      { passive: false },
    );

    // Keyboard controls
    el.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        // Enter opens HUD for the active petal
        if (el.classList.contains("active")) {
          openHud(index);
        } else {
          snapToIndex(index, false);
        }
        return;
      }

      // Expand / collapse (space toggles pull)
      if (e.key === " ") {
        e.preventDefault();
        isPulling = !isPulling;
        pullVel = 0;
        start();
        return;
      }

      // Fine depth control
      if (e.key === "ArrowUp") {
        e.preventDefault();
        pullZ = clamp(pullZ + KEY_PULL_STEP, 0, KEY_PULL_MAX);
        isPulling = true;
        start();
        return;
      }

      if (e.key === "ArrowDown") {
        e.preventDefault();
        pullZ = clamp(pullZ - KEY_PULL_STEP, 0, KEY_PULL_MAX);
        if (pullZ === 0) isPulling = false;
        start();
        return;
      }

      if (e.key === "Escape") {
        if (hudOpen) closeHud();
        isPulling = false;
        pullVel = 0;
        start();
      }
    });
  });

  /* INIT */
  applyTransforms();
  updatePetalVisibility();

  /* CLEANUP (ASTRO ROUTES) */
  function cleanup() {
    closeRevealedPetal();
    disarmLongPress();
    cancelAnimationFrame(rafId);
    mq.removeEventListener("change", updateRadius);
  }

  window.addEventListener("astro:before-swap", cleanup);

  document.addEventListener("visibilitychange", () => {
    if (document.hidden) {
      closeRevealedPetal();
      if (hudOpen) closeHud();
    }
  });
</script>

<style>
  .carousel-layer,
  .carousel-viewport,
  .carousel-ring {
    background: transparent;
    border: none;
  }

  .carousel-layer {
    position: fixed;
    inset: 0;
    pointer-events: auto;
    z-index: 6;
    isolation: isolate;
  }

  .carousel-viewport {
    pointer-events: auto;
    position: absolute;
    left: 50%;
    top: calc(50% + 12px);
    transform: translate(-50%, -50%);

    width: clamp(220px, 40vw, 320px);
    height: clamp(220px, 40vw, 320px);

    perspective: 1200px;
    transform-style: preserve-3d;
  }

  .carousel-ring {
    width: 100%;
    height: 100%;
    transform-style: preserve-3d;
    will-change: transform;
  }

  /* Items */
  .carousel-item {
    position: absolute;
    left: 50%;
    top: 50%;

    width: clamp(180px, 32vw, 240px);
    aspect-ratio: 1 / 1;

    border-radius: 50%;
    overflow: visible;

    pointer-events: auto;
    will-change: transform, opacity;
    transform-style: preserve-3d;

    contain: layout paint;
  }

  /* Inner content stays inert visually */
  .carousel-item * {
    pointer-events: none;
  }

  .parallax-layer {
    width: 100%;
    height: 100%;
    aspect-ratio: 1 / 1;
    transform: translateZ(0) scale(var(--panel-scale, 1));
    transition: transform 0.15s ease;
    display: grid;
    place-items: center;
    transform-origin: 50% 50%;
  }

  /* Orb surface */
  .carousel-item .petal-surface {
    width: 100%;
    height: 100%;
    display: grid;
    place-items: center;
    aspect-ratio: 1 / 1;

    pointer-events: auto;
    cursor: grab;
  }

  .carousel-item.active .petal-surface {
    cursor: grab;
  }

  #petal-shell[data-revealed] .carousel-item.active .petal-surface {
    cursor: default;
  }

  .carousel-item.active {
    box-shadow: none;
  }

  /* ───────────────── HUD LAYER ───────────────── */
  .hud-layer {
    position: fixed;
    inset: 0;
    z-index: 20;
    pointer-events: none;
    opacity: 0;
    transform: translateY(6px);
    transition:
      opacity 220ms ease,
      transform 220ms ease;
  }

  .hud-layer[data-open] {
    opacity: 1;
    transform: translateY(0);
    pointer-events: auto;
  }

  .hud-scrim {
    position: absolute;
    inset: 0;
    background: color-mix(in oklch, black 62%, transparent);
    opacity: 0.62;
  }

  :global(html.light) .hud-scrim {
    background: color-mix(in oklch, white 70%, transparent);
    opacity: 0.62;
  }

  /* Position HUD under PageFind input: PageFind uses z-40; we keep this below it. */
  .hud {
    position: absolute;
    left: 50%;
    top: clamp(72px, 10vh, 110px);
    transform: translateX(-50%);

    width: min(1080px, calc(100vw - 2.25rem));
    max-height: calc(100vh - 130px);

    /* no border (per request) */
    background: color-mix(in oklch, black 18%, transparent);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);

    border-radius: 18px;
    overflow: hidden;
  }

  :global(html.light) .hud {
    background: color-mix(in oklch, white 16%, transparent);
  }

  .hud-grid {
    position: relative;
    display: grid;
    grid-template-columns: minmax(280px, 0.85fr) minmax(360px, 1.35fr);
    grid-template-rows: auto 1fr auto;
    gap: 0.9rem;

    padding: 0.95rem 1rem 1rem;
  }

  .hud-panel {
    display: none;
  }
  .hud-panel[data-active] {
    display: contents;
  }

  /* Title above image, aligned left, under PageFind input */
  .hud-title {
    grid-column: 1 / 2;
    grid-row: 1;
    display: flex;
    align-items: center;
    gap: 0.75rem;
    min-height: 3.1rem;
    padding: 0.55rem 0.55rem 0.15rem;
  }

  .hud-title h2 {
    margin: 0;
    font-size: 0.95rem;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    opacity: 0.92;
    flex: 1;
  }

  /* Left block: image then description */
  .hud-left {
    grid-column: 1 / 2;
    grid-row: 2;
    display: grid;
    gap: 0.65rem;
    padding: 0 0.55rem 0.25rem;
    align-content: start;
  }

  .hud-image-wrap {
    position: relative;
    border-radius: 14px;
    overflow: hidden;

    background: color-mix(in oklch, currentColor 8%, transparent);
  }

  /* Scanline ONLY on images */
  .hud-image-wrap::before {
    content: "";
    position: absolute;
    inset: 0;
    pointer-events: none;

    background: repeating-linear-gradient(
      to bottom,
      color-mix(in oklch, currentColor 18%, transparent) 0px,
      transparent 2px,
      transparent 6px
    );
    mix-blend-mode: overlay;
    opacity: 0.22;
  }

  .hud-image-wrap::after {
    content: "";
    position: absolute;
    inset: -20% 0 auto 0;
    height: 40%;
    pointer-events: none;
    background: linear-gradient(
      to bottom,
      transparent,
      color-mix(in oklch, currentColor 20%, transparent),
      transparent
    );
    opacity: 0.22;
    animation: hudScan 3.1s linear infinite;
  }

  @keyframes hudScan {
    0% {
      transform: translateY(-30%);
    }
    100% {
      transform: translateY(180%);
    }
  }

  .hud-image {
    display: block;
    width: 100%;
    height: clamp(180px, 28vh, 260px);
    object-fit: cover;
    transform: translateZ(0);
  }

  .hud-image-fallback {
    width: 100%;
    height: clamp(180px, 28vh, 260px);
    background: linear-gradient(
      135deg,
      color-mix(in oklch, currentColor 12%, transparent),
      transparent
    );
  }

  .hud-desc {
    margin: 0;
    font-size: 0.85rem;
    line-height: 1.35;
    opacity: 0.85;
    padding: 0.1rem 0.05rem 0.25rem;
  }

  /* Right: article (scrollable) */
  .hud-right {
    grid-column: 2 / 3;
    grid-row: 1 / 3;
    padding: 0.55rem 0.55rem 0.25rem;
    min-width: 0;
  }

  .hud-article {
    max-height: calc(100vh - 240px);
    overflow: auto;
    padding-right: 10px;
    scrollbar-width: thin;
  }

  .hud-article::-webkit-scrollbar {
    width: 8px;
  }
  .hud-article::-webkit-scrollbar-thumb {
    background: color-mix(in oklch, currentColor 26%, transparent);
    border-radius: 999px;
  }

  /* Bottom stat cluster (below both columns) */
  .hud-stats {
    grid-column: 1 / -1;
    grid-row: 3;
    display: flex;
    flex-wrap: wrap;
    gap: 0.65rem;
    align-items: center;
    padding: 0.15rem 0.55rem 0.15rem;
  }

  .hud-stat {
    display: inline-flex;
    align-items: baseline;
    gap: 0.4rem;
    padding: 0.45rem 0.6rem;
    border-radius: 999px;
    background: color-mix(in oklch, currentColor 10%, transparent);
  }

  .hud-k {
    font-size: 0.62rem;
    letter-spacing: 0.18em;
    text-transform: uppercase;
    opacity: 0.7;
  }
  .hud-v {
    font-size: 0.78rem;
    opacity: 0.92;
  }

  .hud-open {
    margin-left: auto;
    display: inline-flex;
    align-items: center;
    gap: 0.4rem;
    padding: 0.5rem 0.65rem;
    border-radius: 999px;
    text-decoration: none;
    background: color-mix(in oklch, currentColor 14%, transparent);
    font-size: 0.72rem;
    letter-spacing: 0.16em;
    text-transform: uppercase;
    opacity: 0.92;
  }

  .hud-open:hover {
    background: color-mix(in oklch, currentColor 22%, transparent);
  }

  .hud-close {
    position: absolute;
    right: 0.55rem;
    top: 4.55rem;
    width: 34px;
    height: 34px;
    border-radius: 999px;
    border: none;
    background: color-mix(in oklch, currentColor 12%, transparent);
    color: currentColor;
    cursor: pointer;
    pointer-events: auto;
  }

  .hud-close:hover {
    background: color-mix(in oklch, currentColor 20%, transparent);
  }

  @media (max-width: 920px) {
    .hud-grid {
      grid-template-columns: 1fr;
      grid-template-rows: auto auto 1fr auto;
    }

    .hud-title,
    .hud-left,
    .hud-right {
      grid-column: 1;
    }

    .hud-title {
      grid-row: 1;
    }
    .hud-left {
      grid-row: 2;
    }
    .hud-right {
      grid-row: 3;
    }
    .hud-stats {
      grid-row: 4;
    }

    .hud-close {
      top: 4.35rem;
    }
  }

  /* PETAL VISIBILITY TOGGLE */
  #petal-shell {
    transition:
      opacity 420ms ease,
      transform 520ms cubic-bezier(0.2, 0.7, 0.2, 1);
  }

  #petal-shell:not([data-petals-open]) {
    opacity: 0;
    pointer-events: none;
    transform: translateY(12px) scale(0.98);
  }
</style>
