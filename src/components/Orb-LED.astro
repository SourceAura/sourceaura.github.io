---
import type { CollectionEntry } from "astro:content";

interface Props {
  post: CollectionEntry<"petals">;
  type?: "text" | "audio" | "video" | "photo" | "project";

  // Optional overrides
  width?: number;
  height?: number;

  // Sphere look/perf
  sphereRad?: number;
  projectionScale?: number;
  radiusSp?: number;

  // LED density
  particlesPerFrame?: number;
  maxParticles?: number;
  particleRad?: number;

  // Rotation speeds
  yawSpeed?: number;
  pitchSpeed?: number;
  rollSpeed?: number;

  // Dark glow tuning
  glowBlur?: number;
  glowStrength?: number;

  // How strongly the sampled image color is applied (0..1)
  materialStrength?: number;
}

const {
  post,
  width = 720,
  height = 416,

  sphereRad = 210,
  radiusSp = 1,
  projectionScale = 0.88,

  particlesPerFrame = 12,
  maxParticles = 1100,
  particleRad = 2.0,

  glowBlur = 7,
  glowStrength = 0.45,

  // Default rotation (subtle)
  yawSpeed = (2 * Math.PI) / 1400,
  pitchSpeed = (2 * Math.PI) / 2200,
  rollSpeed = (2 * Math.PI) / 3000,

  materialStrength = 1,
} = Astro.props;

/* Extract first markdown image */
let imageSrc: string | null = null;

const match = post.body.match(/!\[.*?\]\((.*?)\)/);
if (match?.[1]) {
  const raw = match[1].trim();
  imageSrc =
    raw.startsWith("http") || raw.startsWith("/")
      ? raw
      : `/images/${raw.replace(/^\.?\//, "")}`;
}

const uid = `led_${Math.random().toString(16).slice(2)}`;
const canvasId = `${uid}_canvas`;
---

<div class="orb-led-wrap" data-orb-led-root={uid}>
  <canvas id={canvasId} width={width} height={height}></canvas>
</div>

<script
  is:inline
  define:vars={{
    uid,
    canvasId,
    width,
    height,
    sphereRad,
    radiusSp,
    projectionScale,
    particlesPerFrame,
    maxParticles,
    particleRad,
    glowBlur,
    glowStrength,
    yawSpeed,
    pitchSpeed,
    rollSpeed,
    imageSrc,
    materialStrength,
  }}
>
  (() => {
    // Prevent double-mount on Astro nav
    window.__orbLedMounted ??= new Set();
    if (window.__orbLedMounted.has(uid)) return;
    window.__orbLedMounted.add(uid);

    const canvas = document.getElementById(canvasId);
    const ctx = canvas?.getContext("2d");
    if (!canvas || !ctx) return;

    const reduceMotion = matchMedia("(prefers-reduced-motion: reduce)").matches;

    const displayWidth = canvas.width;
    const displayHeight = canvas.height;

    const fLen = 320;
    const projCenterX = displayWidth / 2;
    const projCenterY = displayHeight / 2;

    // center compensation
    const centerYOffset = -sphereRad * 0.15;

    const zMax = fLen - 2;
    const particleAlpha = 1;

    // Rotation angles
    let rotYaw = 0;
    let rotPitch = 0;
    let rotRoll = 0;

    const zeroAlphaDepth = -750;

    // Linked list + recycle bin
    const particleList = { first: null };
    const recycleBin = { first: null };
    let liveCount = 0;

    const sphereCenterY = 0;
    const sphereCenterZ = () => -3 - sphereRad;

    let raf = 0;

    // Cached theme/composite
    let cachedMode = "source-over";
    let cachedGlow = "off";

    // Fallback color if no image
    let fallbackRGB = "0,0,0";

    function refreshRenderStyle() {
      const rootStyle = getComputedStyle(document.documentElement);
      const wrap = document.querySelector(`[data-orb-led-root="${uid}"]`);
      const wrapStyle = wrap ? getComputedStyle(wrap) : rootStyle;

      const c = wrapStyle.color;
      const m = c.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
      fallbackRGB = m ? `${m[1]},${m[2]},${m[3]}` : "0,0,0";

      cachedMode =
        rootStyle.getPropertyValue("--ps-composite-mode").trim() ||
        "source-over";
      cachedGlow = rootStyle.getPropertyValue("--ps-glow").trim() || "off";
    }

    refreshRenderStyle();

    const moTheme = new MutationObserver(refreshRenderStyle);
    moTheme.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ["class"],
    });

    const wrapEl = document.querySelector(`[data-orb-led-root="${uid}"]`);
    const moWrap = new MutationObserver(refreshRenderStyle);
    if (wrapEl)
      moWrap.observe(wrapEl, {
        attributes: true,
        attributeFilter: ["style", "class"],
      });

    // ---- Material image sampling (offscreen canvas) ----
    let texReady = false;
    let texW = 0;
    let texH = 0;
    let texData = null; // Uint8ClampedArray
    let texCanvas = null;
    let texCtx = null;

    function loadTexture(src) {
      if (!src) return;

      const img = new Image();
      img.crossOrigin = "anonymous";
      img.decoding = "async";
      img.loading = "eager";
      img.src = src;

      img.onload = () => {
        // Keep texture modest to reduce memory + sampling cost
        const maxDim = 256;
        const scale = Math.min(
          1,
          maxDim / Math.max(img.naturalWidth, img.naturalHeight),
        );
        texW = Math.max(1, Math.floor(img.naturalWidth * scale));
        texH = Math.max(1, Math.floor(img.naturalHeight * scale));

        texCanvas = document.createElement("canvas");
        texCanvas.width = texW;
        texCanvas.height = texH;
        texCtx = texCanvas.getContext("2d", { willReadFrequently: true });

        if (!texCtx) return;

        texCtx.drawImage(img, 0, 0, texW, texH);
        const imgData = texCtx.getImageData(0, 0, texW, texH);
        texData = imgData.data;
        texReady = true;
      };

      img.onerror = () => {
        texReady = false;
      };
    }

    loadTexture(imageSrc);

    function sampleTexture(u, v) {
      // u,v in [0,1]
      if (!texReady || !texData) return null;

      // wrap horizontally, clamp vertically
      u = u - Math.floor(u);
      v = Math.max(0, Math.min(1, v));

      const x = Math.floor(u * (texW - 1));
      const y = Math.floor(v * (texH - 1));
      const idx = (y * texW + x) * 4;

      const r = texData[idx];
      const g = texData[idx + 1];
      const b = texData[idx + 2];
      const a = texData[idx + 3] / 255;

      return { r, g, b, a };
    }

    // ---- Particles are "LEDs" on a sphere: store theta/phi so they stay on surface ----
    function addParticle(theta, phi) {
      let p = recycleBin.first || {};
      if (recycleBin.first) {
        recycleBin.first = p.next;
        if (p.next) p.next.prev = null;
      }

      p.next = particleList.first;
      if (particleList.first) particleList.first.prev = p;
      particleList.first = p;
      p.prev = null;

      p.theta = theta; // 0..2pi
      p.phi = phi; // 0..pi

      p.age = 0;
      p.dead = false;

      p.attack = 40;
      p.hold = 120;
      p.decay = 140;
      p.initValue = 0;
      p.holdValue = particleAlpha;
      p.lastValue = 0;

      // Keep them basically always alive, but still cycle alpha slightly
      p.stuckTime = 0;

      liveCount++;
      return p;
    }

    function recycle(p) {
      if (particleList.first === p) {
        particleList.first = p.next;
        if (p.next) p.next.prev = null;
      } else {
        if (p.prev) p.prev.next = p.next;
        if (p.next) p.next.prev = p.prev;
      }

      p.next = recycleBin.first;
      if (recycleBin.first) recycleBin.first.prev = p;
      recycleBin.first = p;
      p.prev = null;

      liveCount = Math.max(0, liveCount - 1);
    }

    function spawn() {
      if (liveCount >= maxParticles) return;
      const remaining = maxParticles - liveCount;
      const n = Math.min(particlesPerFrame, remaining);

      for (let i = 0; i < n; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(Math.random() * 2 - 1);
        addParticle(theta, phi);
      }
    }

    function draw() {
      spawn();

      rotYaw = (rotYaw + yawSpeed) % (Math.PI * 2);
      rotPitch = (rotPitch + pitchSpeed) % (Math.PI * 2);
      rotRoll = (rotRoll + rollSpeed) % (Math.PI * 2);

      const cy = Math.cos(rotYaw),
        sy = Math.sin(rotYaw);
      const cx = Math.cos(rotPitch),
        sx = Math.sin(rotPitch);
      const cz = Math.cos(rotRoll),
        sz = Math.sin(rotRoll);

      ctx.clearRect(0, 0, displayWidth, displayHeight);

      ctx.globalCompositeOperation = cachedMode;

      if (cachedGlow === "on") {
        ctx.shadowBlur = glowBlur;
        ctx.shadowColor = `rgba(255,255,255,0.55)`; // neutral glow, material provides color
      } else {
        ctx.shadowBlur = 0;
        ctx.shadowColor = "transparent";
      }

      const scz = sphereCenterZ();

      let p = particleList.first;
      while (p) {
        const next = p.next;
        p.age++;

        // spherical position (sphere surface)
        const x0 = sphereRad * Math.sin(p.phi) * Math.cos(p.theta);
        const y0 = sphereRad * Math.sin(p.phi) * Math.sin(p.theta);
        const z0 = sphereRad * Math.cos(p.phi);

        // local coords
        let x = x0;
        let y = y0;
        let z = z0;

        // pitch X
        let y1 = cx * y - sx * z;
        let z1 = sx * y + cx * z;

        // yaw Y
        let x2 = cy * x + sy * z1;
        let z2 = -sy * x + cy * z1;

        // roll Z
        let x3 = cz * x2 - sz * y1;
        let y3 = sz * x2 + cz * y1;

        // world z
        const rotX = x3;
        const rotY = y3;
        const rotZ = z2 + scz;

        // projection
        const m = (radiusSp * fLen * projectionScale) / (fLen - rotZ);
        const px = rotX * m + projCenterX;
        const py = rotY * m + projCenterY + centerYOffset;

        // cull
        if (
          px < 0 ||
          px > displayWidth ||
          py < 0 ||
          py > displayHeight ||
          rotZ > zMax
        ) {
          // For a rigid display sphere, don't recycle; just skip drawing.
          p = next;
          continue;
        }

        // envelope alpha (gentle)
        if (p.age < p.attack + p.hold + p.decay) {
          if (p.age < p.attack) p.alpha = (p.holdValue / p.attack) * p.age;
          else if (p.age < p.attack + p.hold) p.alpha = p.holdValue;
          else {
            p.alpha =
              ((p.lastValue - p.holdValue) / p.decay) *
                (p.age - p.attack - p.hold) +
              p.holdValue;
          }
        } else {
          // loop the envelope instead of killing
          p.age = 0;
          p.alpha = 0;
        }

        // Depth term
        let depth = 1 - rotZ / zeroAlphaDepth;
        depth = Math.max(0, Math.min(1, depth));
        const depthAlpha = Math.pow(depth, 1.35);

        // Compute UV: theta wraps, phi maps vertically
        // As the sphere rotates, the LED’s “world” theta changes; easiest is to offset u by yaw.
        const u = p.theta / (Math.PI * 2) + rotYaw / (Math.PI * 2);
        const v = p.phi / Math.PI;

        const tex = sampleTexture(u, v);

        let rgb;
        let texAlpha = 1;

        if (tex) {
          rgb = `${tex.r},${tex.g},${tex.b}`;
          texAlpha = tex.a;
        } else {
          rgb = fallbackRGB;
        }

        // Simple lighting using normal (rotated point on sphere)
        // Normal approx is (rotX,rotY,z2) normalized by sphereRad
        const nx = rotX / sphereRad;
        const ny = rotY / sphereRad;
        const nz = z2 / sphereRad;

        let lit = nx * -0.35 + ny * -0.25 + nz * 0.9;
        lit = Math.max(0, lit);
        lit = Math.pow(lit, 1.25);

        const lightingBoost = 0.35 + 0.85 * lit;

        const alphaBoost = cachedGlow === "on" ? glowStrength : 1;

        // Final alpha: materialAlpha * envelope * depth * lighting
        const a = texAlpha * p.alpha * depthAlpha * lightingBoost * alphaBoost;

        // LED-ish: clamp alpha so points look like lit pixels
        const ledAlpha = Math.min(1, a * materialStrength);

        ctx.fillStyle = `rgba(${rgb}, ${ledAlpha})`;

        // Slight depth-based size scaling
        const nearBoost = 0.75 + depth * 0.55;

        ctx.beginPath();
        ctx.arc(px, py, m * particleRad * nearBoost, 0, Math.PI * 2);
        ctx.fill();

        p = next;
      }

      ctx.globalCompositeOperation = "source-over";
      raf = requestAnimationFrame(draw);
    }

    if (!reduceMotion) draw();

    window.addEventListener(
      "astro:before-swap",
      () => {
        cancelAnimationFrame(raf);
        moTheme.disconnect();
        moWrap.disconnect();
        window.__orbLedMounted.delete(uid);
      },
      { once: true },
    );
  })();
</script>

<style>
  .orb-led-wrap {
    display: flex;
    justify-content: center;
    align-items: center;
    color: inherit;
  }

  canvas {
    display: block;
    max-width: 100%;
    height: auto;
    background: transparent;
  }

  :global(html.dark) {
    --ps-composite-mode: lighter;
    --ps-glow: on;
  }

  :global(html.light) {
    --ps-composite-mode: multiply;
    --ps-glow: off;
  }
</style>
