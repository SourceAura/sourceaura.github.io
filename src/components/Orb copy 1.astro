---
/**
 * SpiritOrbs.astro (v4)
 * No Three.js.
 * Adds:
 *  - Pressure waves propagating between orbs
 *  - Spirit trails (fading behind motes)
 *  - Energy memory (click “scars” that slowly fade)
 *  - Sound-reactive resonance (very subtle, starts after first interaction)
 *
 * Usage:
 * <SpiritOrbs count={3} />
 */
const { count = 3 } = Astro.props;
---

<style>
  :root {
    /* Dark-mode defaults */
    --water: rgba(120, 190, 255, 0.55);
    --water2: rgba(70, 120, 220, 0.28);
    --fire: rgba(255, 140, 90, 0.45);
    --fire2: rgba(180, 120, 255, 0.22);
    --rim: rgba(220, 245, 255, 0.28);
    --bgGlow: rgba(140, 200, 255, 0.45);
    --bgGlow2: rgba(255, 150, 95, 0.32);
  }

  @media (prefers-color-scheme: light) {
    :root {
      --water: rgba(70, 130, 255, 0.4);
      --water2: rgba(20, 60, 160, 0.16);
      --fire: rgba(255, 110, 70, 0.3);
      --fire2: rgba(120, 80, 255, 0.16);
      --rim: rgba(40, 90, 130, 0.18);
      --bgGlow: rgba(70, 140, 255, 0.25);
      --bgGlow2: rgba(255, 140, 90, 0.18);
    }
  }

  .orbs {
    width: 100%;
    height: 100%;
    display: grid;
    place-items: center;
    gap: 18px;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  }

  /* ~2/3 size */
  .orb {
    width: min(260px, 100%);
    aspect-ratio: 1 / 1;
    position: relative;
    touch-action: manipulation;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    transform: translateZ(0);
  }

  .orb svg {
    width: 100%;
    height: 100%;
    display: block;
  }

  .orb-glow {
    filter: drop-shadow(0 0 12px var(--bgGlow))
      drop-shadow(0 0 18px var(--bgGlow2));
  }

  .additive {
    mix-blend-mode: screen;
  }
  .rings {
    pointer-events: none;
  }

  /* Very subtle resonance bump */
  .orb[data-pulse="1"] {
    transform: scale(1.012) translateZ(0);
  }

  @media (prefers-reduced-motion: reduce) {
    .orb {
      transform: none !important;
    }
  }
</style>

<div class="orbs" client:load data-count={count}>
  <template id="orb-template">
    <div class="orb">
      <svg viewBox="0 0 400 400" aria-label="Spirit orb">
        <defs>
          <!-- Water: double turbulence + displacement -->
          <filter
            id="waterSurface__ID"
            x="-45%"
            y="-45%"
            width="190%"
            height="190%"
          >
            <feTurbulence
              id="turbSlow__ID"
              type="fractalNoise"
              baseFrequency="0.008"
              numOctaves="2"
              seed="4"
              result="slow"></feTurbulence>
            <feTurbulence
              id="turbFast__ID"
              type="turbulence"
              baseFrequency="0.040"
              numOctaves="1"
              seed="15"
              result="fast"></feTurbulence>
            <feComposite
              in="slow"
              in2="fast"
              operator="arithmetic"
              k1="0"
              k2="0.75"
              k3="0.55"
              k4="0"
              result="combo"></feComposite>
            <feDisplacementMap
              id="disp__ID"
              in="SourceGraphic"
              in2="combo"
              scale="20"
              xChannelSelector="R"
              yChannelSelector="G"></feDisplacementMap>
          </filter>

          <!-- Fire wisp -->
          <filter
            id="fireWisp__ID"
            x="-55%"
            y="-55%"
            width="210%"
            height="210%"
          >
            <feTurbulence
              id="fireTurb__ID"
              type="turbulence"
              baseFrequency="0.022"
              numOctaves="2"
              seed="3"
              result="f"></feTurbulence>
            <feDisplacementMap in="SourceGraphic" in2="f" scale="22"
            ></feDisplacementMap>
            <feGaussianBlur stdDeviation="1.4"></feGaussianBlur>
          </filter>

          <!-- Caustic rim band -->
          <filter
            id="caustics__ID"
            x="-55%"
            y="-55%"
            width="210%"
            height="210%"
          >
            <feTurbulence
              id="cauTurb__ID"
              type="turbulence"
              baseFrequency="0.9"
              numOctaves="1"
              seed="21"
              result="c"></feTurbulence>
            <feDisplacementMap in="SourceGraphic" in2="c" scale="8"
            ></feDisplacementMap>
            <feGaussianBlur stdDeviation="0.6"></feGaussianBlur>
          </filter>

          <!-- Crackle ring -->
          <filter id="crackle__ID" x="-50%" y="-50%" width="200%" height="200%">
            <feTurbulence
              type="fractalNoise"
              baseFrequency="0.8"
              numOctaves="1"
              seed="11"></feTurbulence>
            <feDisplacementMap scale="6"></feDisplacementMap>
            <feGaussianBlur stdDeviation="0.5"></feGaussianBlur>
          </filter>

          <radialGradient id="waterGrad__ID" cx="35%" cy="30%" r="70%">
            <stop offset="0%" stop-color="rgba(255,255,255,0.88)"></stop>
            <stop offset="34%" stop-color="var(--water)"></stop>
            <stop offset="62%" stop-color="var(--water2)"></stop>
            <stop offset="100%" stop-color="rgba(0,0,0,0)"></stop>
          </radialGradient>

          <radialGradient id="fireGrad__ID" cx="55%" cy="60%" r="55%">
            <stop offset="0%" stop-color="rgba(255,220,160,0.70)"></stop>
            <stop offset="36%" stop-color="var(--fire)"></stop>
            <stop offset="70%" stop-color="var(--fire2)"></stop>
            <stop offset="100%" stop-color="rgba(0,0,0,0)"></stop>
          </radialGradient>

          <radialGradient id="rimGrad__ID" cx="40%" cy="35%" r="75%">
            <stop offset="62%" stop-color="rgba(255,255,255,0)"></stop>
            <stop offset="82%" stop-color="var(--rim)"></stop>
            <stop offset="100%" stop-color="rgba(255,255,255,0)"></stop>
          </radialGradient>

          <clipPath id="orbClip__ID">
            <circle cx="200" cy="200" r="100"></circle>
          </clipPath>
        </defs>

        <g class="orb-glow">
          <g clip-path="url(#orbClip__ID)">
            <circle
              class="water"
              cx="200"
              cy="200"
              r="100"
              fill="url(#waterGrad__ID)"
              filter="url(#waterSurface__ID)"></circle>

            <circle
              class="fire additive"
              cx="200"
              cy="205"
              r="80"
              fill="url(#fireGrad__ID)"
              filter="url(#fireWisp__ID)"></circle>

            <!-- Spirits (and their trails) -->
            <g class="additive" id="spirits__ID" opacity="0.95"></g>

            <!-- Energy scars live here -->
            <g id="scars__ID" class="additive" opacity="0.9"></g>

            <circle
              class="caustic additive"
              cx="200"
              cy="200"
              r="100"
              fill="url(#rimGrad__ID)"
              filter="url(#caustics__ID)"></circle>
          </g>

          <!-- Outer ring intentionally removed -->
        </g>

        <g class="rings" id="rings__ID"></g>
      </svg>
    </div>
  </template>
</div>

<script type="module">
  const root = document.querySelector(".orbs");
  const template = document.getElementById("orb-template");

  const COUNT = Number(root?.dataset?.count || 3);
  const prefersReduced =
    window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches ?? false;
  const isMobileish =
    window.matchMedia?.("(max-width: 640px)")?.matches ?? false;

  // Performance knobs
  const FPS = prefersReduced ? 12 : isMobileish ? 28 : 60;
  const frameInterval = 1000 / FPS;

  // Global resonance shared by all orbs
  let globalPulse = 0;
  let globalPulseVel = 0;

  // Pressure waves (propagating between orbs)
  const waves = []; // { t0, originIdx, screenX, screenY, svgX, svgY, fired:Set<number> }
  const WAVE_SPEED_PX_S = isMobileish ? 900 : 1200;
  const WAVE_FREQ = 10.0; // oscillations per second-ish feel
  const WAVE_DECAY = 2.2;

  // Centers cache
  let orbCenters = []; // {x,y} in screen px
  let centersDirty = true;
  const markCentersDirty = () => {
    centersDirty = true;
  };

  // Pause when offscreen
  const visible = new WeakMap();
  const io = new IntersectionObserver(
    (entries) => {
      for (const e of entries) visible.set(e.target, e.isIntersecting);
    },
    { threshold: 0.15 },
  );

  // Audio (sound-reactive resonance) very subtle, starts after first interaction
  let audio = {
    ready: false,
    enabled: false,
    ctx: null,
    analyser: null,
    data: null,
    level: 0,
    smooth: 0,
  };

  async function initAudio() {
    if (audio.ready || prefersReduced) return;
    audio.ready = true;
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const src = ctx.createMediaStreamSource(stream);
      const analyser = ctx.createAnalyser();
      analyser.fftSize = 512;
      analyser.smoothingTimeConstant = 0.85;
      src.connect(analyser);
      audio.ctx = ctx;
      audio.analyser = analyser;
      audio.data = new Uint8Array(analyser.frequencyBinCount);
      audio.enabled = true;
    } catch (_) {
      // Silent failure: orb still works fine without mic
      audio.enabled = false;
    }
  }

  // Create orbs
  const orbs = [];
  for (let i = 0; i < COUNT; i++) {
    const node = template.content.firstElementChild.cloneNode(true);
    const orbId = `orb${i}_${Math.random().toString(16).slice(2)}`;

    const svg = node.querySelector("svg");

    // Rewrite IDs to avoid collisions
    const allWithId = svg.querySelectorAll("[id]");
    for (const el of allWithId) el.id = el.id.replace("__ID", `__${orbId}`);

    // Rewrite URL(#...) references
    const urlAttrs = svg.querySelectorAll("[clip-path],[filter],[fill]");
    for (const el of urlAttrs) {
      for (const a of ["clip-path", "filter", "fill"]) {
        const v = el.getAttribute(a);
        if (v && v.includes("__ID"))
          el.setAttribute(a, v.replace("__ID", `__${orbId}`));
      }
    }

    const rings = svg.querySelector(`#rings__${orbId}`);
    const spiritsG = svg.querySelector(`#spirits__${orbId}`);
    const scarsG = svg.querySelector(`#scars__${orbId}`);

    // Turbulence nodes
    const turbSlow = svg.querySelector(`#turbSlow__${orbId}`);
    const turbFast = svg.querySelector(`#turbFast__${orbId}`);
    const fireTurb = svg.querySelector(`#fireTurb__${orbId}`);
    const cauTurb = svg.querySelector(`#cauTurb__${orbId}`);
    const disp = svg.querySelector(`#disp__${orbId}`);

    // Per-orb motion state (organic random walk)
    const motion = {
      slow: Math.random(),
      fast: Math.random(),
      fire: Math.random(),
      cau: Math.random(),

      // permanent per-orb biases (never change)
      slowBias: 0.6 + Math.random() * 0.8,
      fastBias: 0.6 + Math.random() * 1.0,
      fireBias: 0.7 + Math.random() * 1.2,
      cauBias: 0.8 + Math.random() * 1.1,

      slowVel: 0,
      fastVel: 0,
      fireVel: 0,
      cauVel: 0,

      scarEnergy: 0,
    };

    // Spirits + trails
    const spiritCount = prefersReduced ? 2 : isMobileish ? 3 : 5;
    const trailLen = prefersReduced ? 0 : isMobileish ? 6 : 10;
    const spirits = [];

    for (let s = 0; s < spiritCount; s++) {
      // Main spirit dot
      const dot = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "circle",
      );
      const dotR = (isMobileish ? 1.7 : 2.2) + Math.random() * 1.0;
      dot.setAttribute("r", dotR);
      dot.setAttribute(
        "fill",
        [
          "rgba(200,240,255,0.92)",
          "rgba(255,210,170,0.86)",
          "rgba(190,160,255,0.82)",
        ][s % 3],
      );
      dot.style.mixBlendMode = "screen";
      spiritsG.appendChild(dot);

      // Precreate trail dots (performance-friendly)
      const trailEls = [];
      for (let k = 0; k < trailLen; k++) {
        const tdot = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "circle",
        );
        tdot.setAttribute("r", Math.max(0.9, dotR - 0.7));
        tdot.setAttribute("fill", dot.getAttribute("fill"));
        tdot.style.mixBlendMode = "screen";
        tdot.setAttribute(
          "opacity",
          (0.12 + ((trailLen - k) / trailLen) * 0.18).toFixed(3),
        );
        spiritsG.appendChild(tdot);
        trailEls.push(tdot);
      }

      const a = Math.random() * Math.PI * 2;
      const rr = 16 + Math.random() * 70;
      const x = 200 + Math.cos(a) * rr;
      const y = 200 + Math.sin(a) * rr;

      spirits.push({
        dot,
        trailEls,
        trail: Array.from({ length: trailLen }, () => ({ x, y })),
        x,
        y,
        vx: (Math.random() - 0.5) * 0.7,
        vy: (Math.random() - 0.5) * 0.7,
        tx: 200,
        ty: 200,
        flare: 0,
      });
    }

    // Energy scars (visual + parameter influence)
    const scars = []; // { el, born, life, x, y, strength }

    function addScar(svgX, svgY, strength) {
      // Visual scar: faint distorted ring that lingers
      const c = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "circle",
      );
      c.setAttribute("cx", svgX);
      c.setAttribute("cy", svgY);
      c.setAttribute("r", 8);
      c.setAttribute("fill", "none");
      c.setAttribute("stroke", "rgba(210,240,255,0.35)");
      c.setAttribute("stroke-width", isMobileish ? "1.1" : "1.2");
      c.setAttribute("stroke-dasharray", "2 6 3 10");
      c.style.mixBlendMode = "screen";
      c.setAttribute("filter", `url(#crackle__${orbId})`);
      scarsG.appendChild(c);

      const life = isMobileish ? 2600 : 3600;
      const born = performance.now();

      // Animate radius + fade
      c.animate(
        [
          { r: 8, opacity: 0.35 },
          { r: 70, opacity: 0.0 },
        ],
        {
          duration: life,
          easing: "cubic-bezier(.2,.8,.2,1)",
          fill: "forwards",
        },
      ).onfinish = () => c.remove();

      scars.push({ el: c, born, life, x: svgX, y: svgY, strength });
      motion.scarEnergy = Math.min(2.5, motion.scarEnergy + strength * 1.2);
    }

    // Rings
    function makeRing({
      cx,
      cy,
      r,
      stroke,
      strokeWidth,
      opacity,
      filterId,
      dash,
      blend,
    }) {
      const c = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "circle",
      );
      c.setAttribute("cx", cx);
      c.setAttribute("cy", cy);
      c.setAttribute("r", r);
      c.setAttribute("fill", "none");
      c.setAttribute("stroke", stroke);
      c.setAttribute("stroke-width", strokeWidth);
      c.setAttribute("opacity", opacity);
      if (filterId) c.setAttribute("filter", `url(#${filterId})`);
      if (dash) c.setAttribute("stroke-dasharray", dash);
      if (blend) c.style.mixBlendMode = blend;
      c.setAttribute("vector-effect", "non-scaling-stroke");
      return c;
    }

    function spawnRipple(x, y) {
      const c = makeRing({
        cx: x,
        cy: y,
        r: 10,
        stroke: "rgba(180, 230, 255, 0.85)",
        strokeWidth: isMobileish ? 1.6 : 2.0,
        opacity: 1,
      });

      // clip ripple inside orb to avoid bounding-box artifact
      c.setAttribute("clip-path", `url(#orbClip__${orbId})`);

      rings.appendChild(c);

      c.animate(
        [
          { r: 10, opacity: 0.85 },
          { r: 155, opacity: 0 },
        ],
        {
          duration: 1100,
          easing: "cubic-bezier(.18,.85,.22,1)",
          fill: "forwards",
        },
      ).onfinish = () => c.remove();
    }

    // Spawn Crackle
    function spawnCrackle(x, y) {
      const c = makeRing({
        cx: x,
        cy: y,
        r: 6,
        stroke: "rgba(220,245,255,0.95)",
        strokeWidth: isMobileish ? 1.2 : 1.4,
        opacity: 1,
        filterId: `crackle__${orbId}`,
        dash: "2 6 3 10",
        blend: "screen",
      });

      // keep crackle fully inside orb
      c.setAttribute("clip-path", `url(#orbClip__${orbId})`);

      rings.appendChild(c);

      c.animate(
        [
          { r: 6, opacity: 0.9 },
          { r: 48, opacity: 0 },
        ],
        {
          duration: 520,
          easing: "cubic-bezier(.3,.9,.2,1)",
          fill: "forwards",
        },
      ).onfinish = () => c.remove();
    }

    // Pointer mapping
    function svgPoint(evt) {
      const pt = svg.createSVGPoint();
      pt.x = evt.clientX;
      pt.y = evt.clientY;
      return pt.matrixTransform(svg.getScreenCTM().inverse());
    }
    function insideOrb(x, y) {
      const dx = x - 200,
        dy = y - 200;
      return dx * dx + dy * dy <= 100 * 100;
    }

    // Spirits react to click
    function spiritsTo(x, y) {
      for (const sp of spirits) {
        sp.tx = x + (Math.random() - 0.5) * 14;
        sp.ty = y + (Math.random() - 0.5) * 14;
        sp.flare = 1;
      }
    }

    // Click: local effects + global resonance + pressure wave dispatch + energy memory
    node.addEventListener(
      "pointerdown",
      (e) => {
        const p = svgPoint(e);
        if (!insideOrb(p.x, p.y)) return;

        // Start audio only after a real user gesture
        initAudio();

        spawnRipple(p.x, p.y);
        spawnCrackle(p.x, p.y);
        setTimeout(() => spawnRipple(p.x, p.y), 120);

        // Memory scar
        addScar(p.x, p.y, 0.9);

        // Spirits dart toward click
        spiritsTo(p.x, p.y);

        // Global resonance kick
        globalPulseVel += 0.85;

        // Pressure wave
        const rect = node.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        waves.push({
          t0: performance.now(),
          originIdx: i,
          screenX: centerX,
          screenY: centerY,
          svgX: p.x,
          svgY: p.y,
          fired: new Set([i]), // origin is already "hit"
        });
        centersDirty = true;
      },
      { passive: true },
    );

    root.appendChild(node);
    io.observe(node);

    orbs.push({
      idx: i,
      node,
      svg,
      rings,
      spirits,
      scars,
      motion,
      turbSlow,
      turbFast,
      fireTurb,
      cauTurb,
      disp,
      orbId,
    });
  }

  // Update centers (called lazily)
  function updateCenters() {
    orbCenters = orbs.map((o) => {
      const r = o.node.getBoundingClientRect();
      return { x: r.left + r.width / 2, y: r.top + r.height / 2 };
    });
    centersDirty = false;
  }

  window.addEventListener("resize", markCentersDirty, { passive: true });
  window.addEventListener("scroll", markCentersDirty, { passive: true });
  document.addEventListener("visibilitychange", () => {
    /* handled by RAF naturally */
  });

  const clamp01 = (v) => Math.max(0, Math.min(1, v));

  // Organic random walk helper
  function wander(v, vel, strength, damping) {
    vel += (Math.random() - 0.5) * strength;
    vel *= damping;
    v += vel;
    return [v, vel];
  }

  // Audio level -> subtle pulse
  function updateAudioLevel() {
    if (!audio.enabled || !audio.analyser) return 0;
    audio.analyser.getByteFrequencyData(audio.data);
    let sum = 0;
    // Use low-mid bins for “thrum” rather than harsh highs
    const start = 2;
    const end = Math.min(22, audio.data.length - 1);
    for (let i = start; i <= end; i++) {
      const v = audio.data[i] / 255;
      sum += v * v;
    }
    const rms = Math.sqrt(sum / (end - start + 1));
    // Smooth + keep it subtle
    audio.smooth = audio.smooth * 0.9 + rms * 0.1;
    return audio.smooth;
  }

  // Main loop
  let last = performance.now();
  let acc = 0;

  function tick(now) {
    requestAnimationFrame(tick);

    const dtMs = now - last;
    last = now;
    acc += dtMs;
    if (acc < frameInterval) return;
    const step = acc / 1000;
    acc = 0;

    if (prefersReduced) return;

    if (centersDirty) updateCenters();

    // Sound-reactive resonance (very subtle)
    const audioLevel = updateAudioLevel();
    if (audioLevel > 0.02) {
      // Tiny nudge. Think “breath”, not “equalizer”.
      globalPulseVel += audioLevel * 0.08;
    }

    // Global resonance: damped
    globalPulseVel *= 0.86;
    globalPulse += globalPulseVel * step;
    globalPulse *= 0.9;
    globalPulse = clamp01(globalPulse);

    // Pressure waves: compute influence per orb and trigger arrival effects
    const waveInfluence = new Array(orbs.length).fill(0);

    for (let w = waves.length - 1; w >= 0; w--) {
      const wave = waves[w];
      const age = (now - wave.t0) / 1000;
      if (age > 2.2) {
        waves.splice(w, 1);
        continue;
      }

      for (let j = 0; j < orbs.length; j++) {
        const a = orbCenters[wave.originIdx];
        const b = orbCenters[j];
        if (!a || !b) continue;

        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const delay = dist / WAVE_SPEED_PX_S;
        const localT = age - delay;
        if (localT <= 0) continue;

        // Damped oscillation
        const env = Math.exp(-WAVE_DECAY * localT);
        const osc = Math.sin(localT * WAVE_FREQ * Math.PI * 2);
        const val = env * (0.5 + 0.5 * osc); // 0..env
        waveInfluence[j] += val * 0.55;

        // Arrival trigger: once per orb per wave
        if (!wave.fired.has(j) && localT > 0.02) {
          wave.fired.add(j);

          // Soft arrival ripple at orb center (pressure wave)
          const orb = orbs[j];
          orb.rings.appendChild(
            (() => {
              const c = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle",
              );
              c.setAttribute("cx", 200);
              c.setAttribute("cy", 200);
              c.setAttribute("r", 10);
              c.setAttribute("fill", "none");
              c.setAttribute("stroke", "rgba(190,235,255,0.35)");
              c.setAttribute("stroke-width", isMobileish ? "1.1" : "1.3");
              c.setAttribute("opacity", "0.9");
              c.style.mixBlendMode = "screen";
              c.animate(
                [
                  { r: 10, opacity: 0.55 },
                  { r: 110, opacity: 0 },
                ],
                {
                  duration: 720,
                  easing: "cubic-bezier(.2,.8,.2,1)",
                  fill: "forwards",
                },
              ).onfinish = () => c.remove();
              return c;
            })(),
          );

          // Spirits in other orbs “listen” and drift inward briefly
          for (const sp of orbs[j].spirits) {
            sp.tx = 200 + (Math.random() - 0.5) * 16;
            sp.ty = 200 + (Math.random() - 0.5) * 16;
            sp.flare = Math.max(sp.flare, 0.35);
          }

          // Tiny shared resonance bump
          globalPulseVel += 0.06;
        }
      }
    }

    // Update each orb
    for (let idx = 0; idx < orbs.length; idx++) {
      const o = orbs[idx];
      if (!visible.get(o.node)) continue;

      const q = isMobileish ? 0.75 : 1.0;

      // Mark pulse UI
      const combinedPulse = clamp01(globalPulse + waveInfluence[idx] * 0.35);
      o.node.dataset.pulse = combinedPulse > 0.1 ? "1" : "0";

      // Organic drift (non-looping)
      const m = o.motion;
      [m.slow, m.slowVel] = wander(m.slow, m.slowVel, 0.0006, 0.96);
      [m.fast, m.fastVel] = wander(m.fast, m.fastVel, 0.0012, 0.94);
      [m.fire, m.fireVel] = wander(m.fire, m.fireVel, 0.0018, 0.92);
      [m.cau, m.cauVel] = wander(m.cau, m.cauVel, 0.001, 0.95);

      // Energy memory decays slowly
      m.scarEnergy *= 0.992;
      const memory = clamp01(m.scarEnergy / 2.5);

      // Base frequencies (drifty)
      const slowBF = (0.006 + m.slow * 0.006) * m.slowBias * q;
      const fastBF = (0.026 + m.fast * 0.028) * m.fastBias * q;
      const fireBF = (0.016 + m.fire * 0.026) * m.fireBias * q;
      const cauBF = (0.6 + m.cau * 1.1) * m.cauBias;

      // Memory + sound subtly bias the turbulence (scars leave “texture”)
      const soundBias = audioLevel * 0.006;
      o.turbSlow?.setAttribute(
        "baseFrequency",
        (slowBF + memory * 0.001 + soundBias).toFixed(4),
      );
      o.turbFast?.setAttribute(
        "baseFrequency",
        (fastBF + memory * 0.006 + soundBias * 2).toFixed(4),
      );
      o.fireTurb?.setAttribute(
        "baseFrequency",
        (fireBF + memory * 0.006 + soundBias).toFixed(4),
      );
      o.cauTurb?.setAttribute(
        "baseFrequency",
        (cauBF + memory * 0.12).toFixed(3),
      );

      // Displacement = base + drift + resonance + wave + tiny audio
      const baseScale = 18 * q;
      const driftScale = baseScale + m.slow * 10 + memory * 6;
      const waveScale = waveInfluence[idx] * 14;
      const audioScale = audioLevel * 4.0;
      const pulseScale = driftScale + globalPulse * 14 + waveScale + audioScale;

      o.disp?.setAttribute("scale", pulseScale.toFixed(2));

      // Spirits: trails + organic damping jitter
      for (const sp of o.spirits) {
        // store current for trail
        if (sp.trail.length) {
          sp.trail.pop();
          sp.trail.unshift({ x: sp.x, y: sp.y });
        }

        const ax = (sp.tx - sp.x) * 0.012;
        const ay = (sp.ty - sp.y) * 0.012;

        // Slight randomness keeps motion from synchronizing
        const damp = 0.9 + Math.random() * 0.03;
        sp.vx = (sp.vx + ax) * damp;
        sp.vy = (sp.vy + ay) * damp;

        // Small shove from resonance/waves
        const shove = combinedPulse * 0.2 + waveInfluence[idx] * 0.15;
        sp.vx += (Math.random() - 0.5) * shove;
        sp.vy += (Math.random() - 0.5) * shove;

        sp.x += sp.vx;
        sp.y += sp.vy;

        // Keep inside orb radius
        const dx = sp.x - 200;
        const dy = sp.y - 200;
        const R = 92;
        const r2 = dx * dx + dy * dy;
        if (r2 > R * R) {
          const r = Math.sqrt(r2) || 1;
          sp.x = 200 + (dx / r) * R;
          sp.y = 200 + (dy / r) * R;
          sp.vx *= -0.55;
          sp.vy *= -0.55;
        }

        // Flare decays; gets boosted by memory/pulse
        sp.flare *= 0.88;
        const flare = clamp01(sp.flare + combinedPulse * 0.25 + memory * 0.2);
        const opacity = clamp01(0.6 + flare * 0.4);

        // Render main dot
        sp.dot.setAttribute("cx", sp.x.toFixed(2));
        sp.dot.setAttribute("cy", sp.y.toFixed(2));
        sp.dot.setAttribute("opacity", opacity.toFixed(3));

        // Render trail dots
        for (let k = 0; k < sp.trailEls.length; k++) {
          const p = sp.trail[k];
          const el = sp.trailEls[k];
          if (!p) continue;
          el.setAttribute("cx", p.x.toFixed(2));
          el.setAttribute("cy", p.y.toFixed(2));
          // fade + pulse shimmer
          const base =
            0.1 + ((sp.trailEls.length - k) / sp.trailEls.length) * 0.2;
          el.setAttribute(
            "opacity",
            clamp01(base * (0.75 + flare * 0.4)).toFixed(3),
          );
        }

        // Targets slowly drift back toward center
        sp.tx += (200 - sp.tx) * 0.002;
        sp.ty += (200 - sp.ty) * 0.002;
      }
    }
  }

  requestAnimationFrame(tick);
</script>
